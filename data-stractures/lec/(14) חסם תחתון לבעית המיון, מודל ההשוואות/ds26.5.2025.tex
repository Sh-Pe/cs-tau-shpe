%! ~~~ Packages Setup ~~~ 
\documentclass[]{article}
\usepackage{lipsum}
\usepackage{rotating}


% Math packages
\usepackage[usenames]{color}
\usepackage{forest}
\usepackage{ifxetex,ifluatex,amssymb,amsmath,mathrsfs,amsthm,witharrows,mathtools,mathdots}
\usepackage{amsmath}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}
\usepackage[thinc]{esdiff}


% tikz
\usepackage{tikz}
\usetikzlibrary{graphs}
\newcommand\sqw{1}
\newcommand\squ[4][1]{\fill[#4] (#2*\sqw,#3*\sqw) rectangle +(#1*\sqw,#1*\sqw);}


% code 
\usepackage{algorithm2e}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{codeblue}{rgb}{0,0,0.5}
\definecolor{codered}{rgb}{0.5,0.03,0.02}
\definecolor{codegray}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{pythonstylesheet}{
    language=Java,
    emphstyle=\color{deepred},
    backgroundcolor=\color{codegray},
    keywordstyle=\color{deepblue}\bfseries\itshape,
    numberstyle=\scriptsize\color{codenumber},
    basicstyle=\ttfamily\footnotesize,
    commentstyle=\color{codegreen}\itshape,
    breakatwhitespace=false, 
    breaklines=true, 
    captionpos=b, 
    keepspaces=true, 
    numbers=left, 
    numbersep=5pt, 
    showspaces=false,                
    showstringspaces=false,
    showtabs=false, 
    tabsize=4, 
    morekeywords={as,assert,nonlocal,with,yield,self,True,False,None,AssertionError,ValueError,in,else},              % Add keywords here
    keywordstyle=\color{codeblue},
    emph={var, List, Iterable, Iterator},          % Custom highlighting
    emphstyle=\color{codered},
    stringstyle=\color{codegreen},
    showstringspaces=false,
    abovecaptionskip=0pt,belowcaptionskip =0pt,
    framextopmargin=-\topsep, 
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\lstinline!#1!}}
\lstset{style=pythonstylesheet}

\usepackage[style=1,skipbelow=\topskip,skipabove=\topskip,framemethod=TikZ]{mdframed}
\definecolor{bggray}{rgb}{0.85, 0.85, 0.85}
\mdfsetup{leftmargin=0pt,rightmargin=0pt,innerleftmargin=15pt,backgroundcolor=codegray,middlelinewidth=0.5pt,skipabove=5pt,skipbelow=0pt,middlelinecolor=black,roundcorner=5}
\BeforeBeginEnvironment{lstlisting}{\begin{mdframed}\vspace{-0.4em}}
    \AfterEndEnvironment{lstlisting}{\vspace{-0.8em}\end{mdframed}}


% Design
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\forestset{default}
\renewcommand\labelitemi{$\bullet$}
\usepackage{titlesec}
\titleformat{\section}[block]
{\fontsize{15}{15}}
{\sen \dotfill (\thesection)\dotfill\she}
{0em}
{\MakeUppercase}
\usepackage{graphicx}
\graphicspath{ {./} }

\usepackage[colorlinks]{hyperref}
\definecolor{mgreen}{RGB}{25, 160, 50}
\definecolor{mblue}{RGB}{30, 60, 200}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=mgreen,
    linkcolor=black,
    urlcolor=mblue,
    pdftitle={Document by Shahar Perets},
    %	pdfpagemode=FullScreen,
}
\usepackage{yfonts}
\def\gothstart#1{\noindent\smash{\lower3ex\hbox{\llap{\Huge\gothfamily#1}}}
    \parshape=3 3.1em \dimexpr\hsize-3.4em 3.4em \dimexpr\hsize-3.4em 0pt \hsize}
\def\frakstart#1{\noindent\smash{\lower3ex\hbox{\llap{\Huge\frakfamily#1}}}
    \parshape=3 1.5em \dimexpr\hsize-1.5em 2em \dimexpr\hsize-2em 0pt \hsize}



% Hebrew initialzing
\usepackage[bidi=basic]{babel}
\PassOptionsToPackage{no-math}{fontspec}
\babelprovide[main, import, Alph=letters]{hebrew}
\babelprovide[import]{english}
\babelfont[hebrew]{rm}{David CLM}
\babelfont[hebrew]{sf}{David CLM}
%\babelfont[english]{tt}{Monaspace Xenon}
\usepackage[shortlabels]{enumitem}
\newlist{hebenum}{enumerate}{1}

% Language Shortcuts
\newcommand\en[1] {\begin{otherlanguage}{english}#1\end{otherlanguage}}
\newcommand\he[1] {\she#1\sen}
\newcommand\sen   {\begin{otherlanguage}{english}}
    \newcommand\she   {\end{otherlanguage}}
\newcommand\del   {$ \!\! $}

\newcommand\npage {\vfil {\hfil \textbf{\textit{המשך בעמוד הבא}}} \hfil \vfil \pagebreak}
\newcommand\ndoc  {\dotfill \\ \vfil {\begin{center}
            {\textbf{\textit{שחר פרץ, 2025}} \\
                \scriptsize \textit{קומפל ב־}\en{\LaTeX}\,\textit{ ונוצר באמצעות תוכנה חופשית בלבד}}
    \end{center}} \vfil	}

\newcommand{\rn}[1]{
    \textup{\uppercase\expandafter{\romannumeral#1}}
}

\makeatletter
\newcommand{\skipitems}[1]{
    \addtocounter{\@enumctr}{#1}
}
\makeatother

%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}
\newcommand\One   {\mathit{1}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\vc    {\mathcal{V}} % Vance
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\prm   {\mathrm{p}}
\newcommand\arm   {\mathrm{a}} % x86
\newcommand\brm   {\mathrm{b}}
\newcommand\crm   {\mathrm{c}}
\newcommand\drm   {\mathrm{d}}
\newcommand\erm   {\mathrm{e}}
\newcommand\frm   {\mathrm{f}}
\newcommand\nrm   {\mathrm{n}}
\newcommand\vrm   {\mathrm{v}}
\newcommand\srm   {\mathrm{s}}
\newcommand\rrm   {\mathrm{r}}

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\mathrm{, }}
\newcommand\defis {\mathrm{ definitions}}
\newcommand\given {\mathrm{given }}
\newcommand\case  {\mathrm{if }}
\newcommand\syx   {\mathrm{ syntax}}
\newcommand\rle   {\mathrm{ rule}}
\newcommand\other {\mathrm{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathscr{A}\!\mathit{nswer}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\DeclareMathOperator\dom   {dom}
\DeclareMathOperator\Img   {Im}
\DeclareMathOperator\range {range}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}
\newcommand\ceil  [1] {\lc #1 \rc}
\newcommand\floor [1] {\lf #1 \rf}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\logx  {\log x}
\newcommand\lnx   {\ln x}
\newcommand\cosx  {\cos x}
\newcommand\sinx  {\sin x}
\newcommand\sint  {\sin \theta}
\newcommand\tanx  {\tan x}
\newcommand\tant  {\tan \theta}
\newcommand\sex   {\sec x}
\newcommand\sect  {\sec^2}
\newcommand\cotx  {\cot x}
\newcommand\cscx  {\csc x}
\newcommand\sinhx {\sinh x}
\newcommand\coshx {\cosh x}
\newcommand\tanhx {\tanh x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\slh   {\overset{LH}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}
\newcommand\ol    {\overline}

\newcommand\mlcm  {\mathrm{lcm}}

\DeclareMathOperator{\sech}   {sech}
\DeclareMathOperator{\csch}   {csch}
\DeclareMathOperator{\arcsec} {arcsec}
\DeclareMathOperator{\arccot} {arcCot}
\DeclareMathOperator{\arccsc} {arcCsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth}
\DeclareMathOperator{\atant}  {atan2} 
\DeclareMathOperator{\Sp}     {span} 
\DeclareMathOperator{\sgn}    {sgn} 
\DeclareMathOperator{\row}    {Row} 
\DeclareMathOperator{\adj}    {adj} 
\DeclareMathOperator{\rk}     {rank} 
\DeclareMathOperator{\col}    {Col} 
\DeclareMathOperator{\tr}     {tr}

\newcommand\dx    {\,\mathrm{d}x}
\newcommand\dt    {\,\mathrm{d}t}
\newcommand\dtt   {\,\mathrm{d}\theta}
\newcommand\du    {\,\mathrm{d}u}
\newcommand\dv    {\,\mathrm{d}v}
\newcommand\df    {\mathrm{d}f}
\newcommand\dfdx  {\diff{f}{x}}
\newcommand\dit   {\limhz \frac{f(x + h) - f(x)}{h}}

\newcommand\nt[1] {\frac{#1}{#1}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limh  {\lim_{x \to 0}}
\newcommand\limni {\lim_{x \to - \infty}}
\newcommand\limpmi{\lim_{x \to \pm \infty}}

\newcommand\ta    {\theta}
\newcommand\ap    {\alpha}

\renewcommand\inf {\infty}
\newcommand  \ninf{-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}
\newcommand\setn      {\{a_i\}^{2n}_{i = 1}}
\newcommand\setc[1]   {\{a_i\}^{#1}_{i = 1}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}
\newcommand\capain    {\bigcap_{i = 1}^{n} A_i}
\newcommand\capai[1]  {\bigcap_{i = 1}^{#1} A_i}
\newcommand\capiiai   {\bigcap_{i \in I} A_i}

\newcommand\xot       {x_{1, 2}}
\newcommand\ano       {a_{n - 1}}
\newcommand\ant       {a_{n - 2}}

% Linear Algebra
\DeclareMathOperator{\chr}     {char}
\DeclareMathOperator{\diag}    {diag}
\DeclareMathOperator{\Hom}     {Hom}
\DeclareMathOperator{\Sym}     {Sym}
\DeclareMathOperator{\Asym}    {ASym}

\newcommand\lra       {\leftrightarrow}
\newcommand\chrf      {\chr(\F)}
\newcommand\F         {\mathbb{F}}
\newcommand\co        {\colon}
\newcommand\tmat[2]   {\cl{\begin{matrix}
            #1
        \end{matrix}\, \middle\vert\, \begin{matrix}
            #2
\end{matrix}}}

\makeatletter
\newcommand\rrr[1]    {\xxrightarrow{1}{#1}}
\newcommand\rrt[2]    {\xxrightarrow{1}[#2]{#1}}
\newcommand\mat[2]    {M_{#1\times#2}}
\newcommand\gmat      {\mat{m}{n}(\F)}
\newcommand\tomat     {\, \dequad \longrightarrow}
\newcommand\pms[1]    {\begin{pmatrix}
        #1
\end{pmatrix}}

% someone's code from the internet: https://tex.stackexchange.com/questions/27545/custom-length-arrows-text-over-and-under
\makeatletter
\newlength\min@xx
\newcommand*\xxrightarrow[1]{\begingroup
    \settowidth\min@xx{$\m@th\scriptstyle#1$}
    \@xxrightarrow}
\newcommand*\@xxrightarrow[2][]{
    \sbox8{$\m@th\scriptstyle#1$}  % subscript
    \ifdim\wd8>\min@xx \min@xx=\wd8 \fi
    \sbox8{$\m@th\scriptstyle#2$} % superscript
    \ifdim\wd8>\min@xx \min@xx=\wd8 \fi
    \xrightarrow[{\mathmakebox[\min@xx]{\scriptstyle#1}}]
    {\mathmakebox[\min@xx]{\scriptstyle#2}}
    \endgroup}
\makeatother


% Greek Letters
\newcommand\ag        {\alpha}
\newcommand\bg        {\beta}
\newcommand\cg        {\gamma}
\newcommand\dg        {\delta}
\newcommand\eg        {\epsi}
\newcommand\zg        {\zeta}
\newcommand\hg        {\eta}
\newcommand\tg        {\theta}
\newcommand\ig        {\iota}
\newcommand\kg        {\keppa}
\renewcommand\lg      {\lambda}
\newcommand\og        {\omicron}
\newcommand\rg        {\rho}
\newcommand\sg        {\sigma}
\newcommand\yg        {\usilon}
\newcommand\wg        {\omega}

\newcommand\Ag        {\Alpha}
\newcommand\Bg        {\Beta}
\newcommand\Cg        {\Gamma}
\newcommand\Dg        {\Delta}
\newcommand\Eg        {\Epsi}
\newcommand\Zg        {\Zeta}
\newcommand\Hg        {\Eta}
\newcommand\Tg        {\Theta}
\newcommand\Ig        {\Iota}
\newcommand\Kg        {\Keppa}
\newcommand\Lg        {\Lambda}
\newcommand\Og        {\Omicron}
\newcommand\Rg        {\Rho}
\newcommand\Sg        {\Sigma}
\newcommand\Yg        {\Usilon}
\newcommand\Wg        {\Omega}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\sof[1]    {\left | #1 \right |}
\newcommand\cl [1]    {\left ( #1 \right )}
\newcommand\csb[1]    {\left [ #1 \right ]}
\newcommand\ccb[1]    {\left \{ #1 \right \}}

\newcommand\bs        {\blacksquare}
\newcommand\dequad    {\!\!\!\!\!\!}
\newcommand\dequadd   {\dequad\duquad}

\renewcommand\phi     {\varphi}

\newtheorem{Theorem}{משפט}
\theoremstyle{definition}
\newtheorem{definition}{הגדרה}
\newtheorem{Lemma}{למה}
\newtheorem{Remark}{הערה}
\newtheorem{Notion}{סימון}


\newcommand\theo  [1] {\begin{Theorem}#1\end{Theorem}}
\newcommand\defi  [1] {\begin{definition}#1\end{definition}}
\newcommand\rmark [1] {\begin{Remark}#1\end{Remark}}
\newcommand\lem   [1] {\begin{Lemma}#1\end{Lemma}}
\newcommand\noti  [1] {\begin{Notion}#1\end{Notion}}

% DS
\newcommand\limsi     {\limsup_{n \to \inf}}
\newcommand\limfi     {\liminf_{n \to \inf}}

\DeclareMathOperator\amort   {amort}
\DeclareMathOperator\worst   {worst}
\DeclareMathOperator\type    {type}
\DeclareMathOperator\cost    {cost}
\DeclareMathOperator\tim     {time}

\newcommand\dsList{
    \sFunc{List}
    \sFunc{Retrieve}
    \SetKwFunction{RetrieveFirst}{Retrieve-First}
    \SetKwFunction{RetrieveLast}{Retrieve-Last}
    \sFunc{Delete}
    \SetKwFunction{DeleteFirst}{Delete-First}
    \SetKwFunction{DeleteLast}{Delete-Last}
    \sFunc{Insert}
    \SetKwFunction{InsertFirst}{Insert-First}
    \SetKwFunction{InsertLast}{Insert-Last}
    \sFunc{Shift}
    \sFunc{Length}
    \sFunc{Concat}
    \sFunc{Plant}
    \sFunc{Split}
}
\newcommand\dsQueue{
    \sFunc{Queue}
    \sFunc{Enqueue}
    \sFunc{Head}
    \sFunc{Dequeue}
}
\newcommand\dsStack{
    \sFunc{Stack}
    \sFunc{Push}
    \sFunc{Top}
    \sFunc{Pop}
}
\newcommand\dsVector{
    \sFunc{Vector}
    \sFunc{Get}
    \sFunc{Set}
}
\newcommand\dsGraph{
    \sFunc{Graph}
    \sFunc{Edge}
    \SetKwFunction{AddEdge}{Add-Edge}
    \SetKwFunction{RemoveEdge}{Remove-Edge}
    \sFunc{InDeg} \sFunc{OutDeg}
}
\newcommand\importDs{
    \dsList
    \dsQueue
    \dsStack
    \dsVector
    \dsGraph
    \SetKwData{error}{\color{codered}error}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwRepeat{Do}{do}{while}
    \SetKwData{Null}{\color{codeblue}null}
}


% Algorithems
\newcommand\sFunc [1] {\SetKwFunction{#1}{#1}}
\newcommand\sData [1] {\SetKwData{#1}{#1}}
\newcommand\sIO   [1] {\SetKwInOut{#1}{#1}}
\newcommand\ttt   [1] {\sen \texttt{#1} \she\,}
\newcommand\io    [2] {\Input{#1}\Output{#2}\BlankLine}

%! ~~~ Document ~~~

\author{שחר פרץ}
\title{\textit{מבני נתונים 14}}
\begin{document}
    \maketitle
    
    \section{\en{Sorting}}
    פורמלית, עד עתה לא ראינו חסם תחתון למיון. נראה שהוא $\Theta(n\logn)$. נגדיר את בעית המיון: 
    
    \textbf{קלט: }$n$ איברים שהם totally ordered (יחס סדר מלא). 
    \textbf{פלט: }אותם איברים לפי הסדר, מהקטן לגדול. אפשר לחשוב על זה אכל תמורה/פרמוטציה. 
    
    יש $n!$ אפשרויות למה התמורה בין הקלט לפלט. 
    
    יש תכונה של מיון – stable sort (מיון יציב). בעת מיון כזה אם שני איברים שמבחינת הסדר הם שקולים, יש צורך לשמור על הסדר המקורי שלהם בקלט. אנו מכירים כבר מספר מיונים: 
    \begin{center}
        \sen
        \begin{tabular}{|c c c|c c c|c|}
            \hline bubble sort & insertion sort & selection sort & heap sort & merge sort & binary search tree & quick sort \\
            \hline \hfil & $O(n^2)$ & & & \hfill $O(n \logn)$ & & worst $O(n^2)$  \\ &&&&&&avg. $O(n \logn)$ \\ \hline
        \end{tabular}
        \she
    \end{center}
    \textbf{הנחה: }השוואה בין שני איברים לוקחת $O(1)$, וכל האל' הנל תשתמש בפעולה זו. 
    
    ראוי לציין שב־quicksort אין קלט ``רע'', רק בחירות אקראיות רעות. המשמעות של זה היא שאי אפשר להנדס שלט שיגדיל בבת אחת את הסיבוכיות. 
    
    \textbf{שאלה: }האם קיימים אל' מהירים יותר? 
    
    חסם עליון הראינו בעזרת דוגמה של אלגו', לעומת חסם תחתון שנצטרך להראות ביחס לכל אלגו' שיכול להיתכן. לדוגמה, נוכל לתת חסם תחתון של $O(n)$ משום שחייבים לבחון כל ערך בקלט. 
    
    \theo{תחת מודל ההשוואות, כל אלג' מיון אץ בזמן $\Omega(n \logn)$ במקרה הגרוע ביותר. }
    
    \begin{proof}{''הוכחה''}
        האלגוריתם יכול אך ורק להשוות. יהיו $x_i, x_j$ כלשהם שהשוותי. נתבונן במרחב $n!$ הפרמוטציות, אזי פמעשה פיצלנו אותן ל־$x_i < x_j$ פרמוטציות והמקרים בהם $x_i > x_j$. בגלל שהאלגוריתם מבוסס השוואות, נוכל להמשיך את המיון הזה לפי אותו הרעיון, כלומר נריץ את אחד המקרים. אידיאלית, נרצה לבחור $x_i, x_j$ כך שננחצה בדיוק לשניים את מרחב הפרמטוציות (ספציפית לגבי הזוג הראשון זה יהיה נכון לכל זוג).נמשיך ב''עץ החלטות'', כלומר באחד מהמקרים, או $x_i < x_j $ או להפך. 
        
        מסתכלים על עץ ההחלטות של האלגו'. בכל השוואה לפי התוצאה (הבינארית), פוצים ללק מהפרטמוטציות. עלה בעץ מייצג פתרון של המיון עאש נשארה פרמוטציה אחת בלבד. 
        
        יש לפחות $n1$ עלים בעץ עבור כל תוצאה אפשרית. לכן, העומד לפחות $\Omega(n!)$. כל ריצה של האלג'ו שקולה למעבר שולש ועד עלה. העץ כולו מאוד גדול, אבל לא בהכרח מחזיקים אותו באמת. זהו עץ אך ורק לניתוח. ראינו ש־$\logn n! = \Theta(n\logn)$. 
    \end{proof}
    אז ניתוח זמן ריצה ב־worst case הוא $O(n \logn)$, עומק עץ החיפוש. זמן הריצה הטוב ביותר הוא $O(n)$ – והוא לעלה עם העומק המינימלי. לדוגמה ב־bubble sort יש ענף כזה בעץ, שמאפשר $O(n)$ לקלט מסודר. זמן ריצה ממוצע שקול לעומק הממוצע של עלה. 
    
    נשאלת השאלה, האם ה־average case הוא $\Omega(n\logn)$ גם כן? 
    
    \theo{על אלג' במודל ההשוואות חייב להיות $\Omega(n \logn )$ }
    \begin{proof}
        באינדוקציה על מספר העלים $\ml$. 
        
        בסיס $\ml = 1$. יהיו $0$ השוואות. 
        עבור $\ml$ כללי, הוא מתפרק ל־$\ml = \ml_1 + \ml_2$ כך שעץ החיפוש:־
        \begin{center}
            \sen\begin{forest}
                [$\cdot$
                    [$\ml_1$]
                    [$\ml_2$]
                ]
            \end{forest}\she
        \end{center}
        כאשר $\ml_1$ מייצג תת־עץ עם $\ml_1$ עלים. אז העומק הממוצע (נשקלל כי בכל עץ כמות אחרת של עלים): 
        \[ \text{\sen avg. case \she} \overset{\text{ה.א.}}{\ge} \frac{\ml_1}{\ml} \cdot \cl{1 + \log \ml_1} + \frac{\ml_2}{\ml}\cl{1 + \log \ml_2} = 1 + \frac{\ml_1 + \ml_1\log\ml_1 + \ml_2\log\ml_2}{\ml} \overset{(1)}{\ge} 1 + \frac{2 \cdot \frac{\ml_1 + \ml_2}{2}\log \cl{\frac{\ml_1 + \ml_2}{2}}}{\ml} = 1 + \log \frac{\ml}{2} = \log \ml \]
        $(1)$ – ידוע שהפונקציה $\log x$ קמורה. היא מקיימת שקו בין שתי נקודות נמצא מעליה, ומא''ש ינסן נקלב שהנקודה $f\cl{\frac{\ml_1 + \ml_2}{2}}$ קטנה מ־$\frac{f(\ml_1) + f(\ml_2)}{2}$. 
    \end{proof}
    
    \textit{הערה לעצמי: }לבדוק איך אני יכול להגדיר לעצמי משהו יותר הדוק מממוצע חשבוני ביחס לאינדוקציה ההיא. 
    
    \theo{גם עבור אלג' לא דטרמיניסטי, מתקיים $\Omega(n \logn)$ זמן מדוסה (תלות). }
    
    
    \textbf{מסקנה. }לא ניתן לבנות עץ חיפוש בינארי על $n$ איברים כלליים בזמן $o(n\logn)$. זוהי רדוקציה לבעיית המיון – אם קיים עץ כזה אזי אפשר בזמן לינארי לעבור עליו ולמצוא מיון. 
    
    ניתן לרדת המסיבוכיות של $O(n \logn)$ כאשר יש מידע נוסף על הקלט. לדוגמא, אם אנחנו חסומים ב־$r$ כלשהו, אפשר לספור כמה פעמים הופיע כל איבר. סיבוכיות $O(n + r)$. פרטים לגבי אופן המימוש + פסאדו קוד שהמרצה לשנו לא מראה נמצאים במצגת, וזהו יוצא מיון יציב. 
    
    נרצה לשפר עבור המקרה של $n$ איברים עד $n^k$. נוכל למיין על סמך ספרת האחדות, ואז עשרות, מאיות וכו'. בטרמינולוגיה של הקורס התחלנו בלמיין ב־least significant digit עד ה־most significant digit. דרך המיון תהיה באמצעות count sort כי אנו חסומים ב־$k$, שהוא מיון יציב (דרוש לתקינות האלגו'). העלות הסופית תהיה $d(b + b)$ כאשר $d$ כמות הספרות ו־$b$ הבסיס שאנו עובדים בו. בפרט עבור $n^k$ חסם עליון נוכל לבחור לעבוד בבסיס $n$, ונקבל $k$ ספרות, וסה''כ $k(n + n) = O(nk)$. נקרא לכך Radix Sort. 
    
    (יואב עירוני לוחש – LSD – least significant digit). 
    
    ניסוח של המרצה: 
    עבור $n$ ממספרים עד $n^k$ נבחר $b = n$, ונקבל $d = k$ ולכן $O(kn)$ זמן. 
    
    \ndoc
\end{document}