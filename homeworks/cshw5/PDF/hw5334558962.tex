%! ~~~ Packages Setup ~~~ 
\documentclass[]{article}


% Math packages
\usepackage[usenames]{color}
\usepackage{forest}
\usepackage{ifxetex,ifluatex,amsmath,amssymb,mathrsfs,amsthm,witharrows,mathtools}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}
\usepackage[thinc]{esdiff}


% tikz
\usepackage{tikz}
\newcommand\sqw{1}
\newcommand\squ[4][1]{\fill[#4] (#2*\sqw,#3*\sqw) rectangle +(#1*\sqw,#1*\sqw);}


% code 
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{codeblue}{rgb}{0,0,0.5}
\definecolor{codered}{rgb}{0.5,0.03,0.02}
\definecolor{codegray}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{pythonstylesheet}{
	language=Python,
	emphstyle=\color{deepred},
	backgroundcolor=\color{codegray},
	keywordstyle=\color{deepblue}\bfseries\itshape,
	numberstyle=\scriptsize\color{codenumber},
	basicstyle=\ttfamily\footnotesize,
	commentstyle=\color{codegreen}\itshape,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false, 
	tabsize=4, 
	morekeywords={as,assert,nonlocal,with,yield,self,True,False,None,AssertionError,ValueError,in,else},              % Add keywords here
	keywordstyle=\color{codeblue},
	emph={object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,print,range,xrange,append,execfile,real,imag,reduce,str,repr,__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,},          % Custom highlighting
	emphstyle=\color{codered},
	stringstyle=\color{codegreen},
	showstringspaces=false,
	abovecaptionskip=0pt,belowcaptionskip =0pt,
	framextopmargin=-\topsep, 
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\lstinline!#1!}}
\lstset{style=pythonstylesheet}

\usepackage[style=1,skipbelow=\topskip,skipabove=\topskip,framemethod=TikZ]{mdframed}
\definecolor{bggray}{rgb}{0.85, 0.85, 0.85}
\mdfsetup{leftmargin=0pt,rightmargin=0pt,innerleftmargin=15pt,backgroundcolor=codegray,middlelinewidth=0.5pt,skipabove=5pt,skipbelow=0pt,middlelinecolor=black,roundcorner=5}
\BeforeBeginEnvironment{lstlisting}{\begin{mdframed}\vspace{-0.4em}}
	\AfterEndEnvironment{lstlisting}{\vspace{-0.8em}\end{mdframed}}


% Deisgn
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\forestset{default}
\renewcommand\labelitemi{$\bullet$}
\usepackage{titlesec}
\titleformat{\section}[block]
{\fontsize{15}{15}}
{\sen \dotfill (\thesection) \she}
{0em}
{\MakeUppercase}
\usepackage{graphicx}
\graphicspath{ {./} }


% Hebrew initialzing
\usepackage[bidi=basic]{babel}
\PassOptionsToPackage{no-math}{fontspec}
\babelprovide[main, import, Alph=letters]{hebrew}
\babelprovide[import]{english}
\babelfont[hebrew]{rm}{David CLM}
\babelfont[hebrew]{sf}{David CLM}
\babelfont[english]{tt}{Monaspace Xenon}
\usepackage[shortlabels]{enumitem}
\newlist{hebenum}{enumerate}{1}

% Language Shortcuts
\newcommand\en[1] {\begin{otherlanguage}{english}#1\end{otherlanguage}}
\newcommand\sen   {\begin{otherlanguage}{english}}
	\newcommand\she   {\end{otherlanguage}}
\newcommand\del   {$ \!\! $}
\newcommand\ttt[1]{\en{\footnotesize\texttt{#1}\normalsize}}

\newcommand\npage {\vfil {\hfil \textbf{\textit{המשך בעמוד הבא}}} \hfil \vfil \pagebreak}
\newcommand\ndoc  {\dotfill \\ \vfil {\begin{center} {\textbf{\textit{שחר פרץ, 2024}} \\ \scriptsize \textit{נוצר באמצעות תוכנה חופשית בלבד}} \end{center}} \vfil	}

\newcommand{\rn}[1]{
	\textup{\uppercase\expandafter{\romannumeral#1}}
}

\makeatletter
\newcommand{\skipitems}[1]{
	\addtocounter{\@enumctr}{#1}
}
\makeatother

%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\text{, }}
\newcommand\defi  {\text{ definition}}
\newcommand\defis {\text{ definitions}}
\newcommand\given {\text{given }}
\newcommand\case  {\text{if }}
\newcommand\syx   {\text{ syntax}}
\newcommand\rle   {\text{ rule}}
\newcommand\other {\text{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathit{Ans.}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\newcommand\dom   {\mathrm{dom}}
\newcommand\Img   {\mathrm{Im}}
\newcommand\range {\mathrm{range}}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\logx  {\log x}
\newcommand\lnx   {\ln x}
\newcommand\cosx  {\cos x}
\newcommand\cost  {\cos \theta}
\newcommand\sinx  {\sin x}
\newcommand\sint  {\sin \theta}
\newcommand\tanx  {\tan x}
\newcommand\tant  {\tan \theta}
\newcommand\sex   {\sec x}
\newcommand\sect  {\sec^2}
\newcommand\cotx  {\cot x}
\newcommand\cscx  {\csc x}
\newcommand\sinhx {\sinh x}
\newcommand\coshx {\cosh x}
\newcommand\tanhx {\tanh x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\slh   {\overset{LH}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}
\newcommand\ol    {\overline}

\newcommand\mlcm  {\mathrm{lcm}}

\DeclareMathOperator{\sech}   {sech}
\DeclareMathOperator{\csch}   {csch}
\DeclareMathOperator{\arcsec} {arcsec}
\DeclareMathOperator{\arccot} {arcCot}
\DeclareMathOperator{\arccsc} {arcCsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth} 

\newcommand\dx    {\,\mathrm{d}x}
\newcommand\dt    {\,\mathrm{d}t}
\newcommand\dtt   {\,\mathrm{d}\theta}
\newcommand\du    {\,\mathrm{d}u}
\newcommand\dv    {\,\mathrm{d}v}
\newcommand\df    {\mathrm{d}f}
\newcommand\dfdx  {\diff{f}{x}}
\newcommand\dit   {\limhz \frac{f(x + h) - f(x)}{h}}

\newcommand\nt[1] {\frac{#1}{#1}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limh  {\lim_{x \to 0}}
\newcommand\limni {\lim_{x \to - \infty}}
\newcommand\limpmi{\lim_{x \to \pm \infty}}

\newcommand\ta    {\theta}
\newcommand\ap    {\alpha}

\renewcommand\inf {\infty}
\newcommand  \ninf{-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}
\newcommand\setn      {\{a_i\}^{2n}_{i = 1}}
\newcommand\setc[1]   {\{a_i\}^{#1}_{i = 1}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}
\newcommand\capain    {\bigcap_{i = 1}^{n} A_i}
\newcommand\capai[1]  {\bigcap_{i = 1}^{#1} A_i}
\newcommand\capiiai   {\bigcap_{i \in I} A_i}

\newcommand\xot       {x_{1, 2}}
\newcommand\ano       {a_{n - 1}}
\newcommand\ant       {a_{n - 2}}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\sof[1]    {\left | #1 \right |}
\newcommand\cl [1]    {\left ( #1 \right )}
\newcommand\csb[1]    {\left [ #1 \right ]}

\newcommand\bs    {\blacksquare}

%! ~~~ Document ~~~

\author{שחר פרץ}
\title{תרגיל בית 5 – מבוא מורחב למדעי־המחשב}

\begin{document}
	\maketitle
	\section{}
	\section{}
	\begin{enumerate}[A.]
		\skipitems{2}
		\item נניח בשלילה קיום גנרטור $g$ המייצא את קבוצת איברי $g$ הגדולים מ־$0$; אזי לכל $f$ גנרטור, $g(f)$ מוגדר היטב. בפרט, עבור $f = \lambda n \in \N. n + 1$. אך, $\Img(f) = \N, \forall n \in \N. n > 0$, כלומר $g(f) = \N$ וסה"כ הפלט אינסופי ובפרט הגנרטור חסר השהייה סופית – סתירה לקיומו. 
		\skipitems{1}
		\item יהי גנרטור $G(g_1, g_2)$ המקבל שני גנרטורים ומחזיר את החיתוך שלהם; נתבונן ב־$g_1 = \lambda n \in \N. 0, \ g_2 = \lambda n \in \N. 1$. ידוע לנו שהחיתוך ריק, אך האלגוריתם יאלץ לעבור על כל $g_1$ ו־$g_2$ על מנת לייצר את החיתוך, כלומר לעבור כל כמות בת־מנייה של מספרים, ובפרט אין־סופית. אזי, לא קיים גנרטור בעל השהייה סופית מתאים, כדרוש. נשים לב שההוכחה נכונה ללא תלות בנתון ש־$g_1, g_2$ בעלי השהייה סופית, שכן תחת ההנחה שקיימת השהייה, מעבר על $\az$ איברים יארך זמן אינסופי. 
		\item נניח בשלילה קיום גנרטור בעל השהייה סופית $G$ המקבל שני גנרטורים $g_1, g_2$ המייצרים את הסדרות $\setc{n}, \{b_i\}_{i = 1}^{n}$, ומייצר את סדרת האיברים המקיימים $a_i \neq b_i$. נבחר $a_1 = a_2 = \dots = a_n = 0, \ b_1 = \dots = b_n = 1$, לכן $\forall i \in \N. a_i = 0 \neq 1 = b_i$. בפרט, $G$ מייצר את $\varnothing$. גם נבחר $n = \inf$, כי נתון בשאלה ששניהם סופיים באותו הגודל, או ששניהם אין־סופיים. אזי, הגנרטור $G$ יאלץ לעבור כל $\{a_n\}$ ו־$\{b_n\}$ כדי להסיק זאת, ומשום ש־$n = \inf$, פעולה זו תיקח זמן אין־סופי – ובפרט, $G$ אינו בעל השהייה סופית. סתירה. 
	\end{enumerate}
	\section{}
	\begin{enumerate}[A.]
		\skipitems{1}
		\item 
		\begin{itemize}
			\item צ.ל. קיום עץ בינארי מושלם $T = \la V, E \ra$ כאשר $|V| = n$ אמ"מ $\exists d \ge 1. n = 2^d - 1$. 
			\begin{proof} \ 
				\begin{itemize}
					\item[$\implies$]
			נניח קיום $d \ge 1$ כך ש־$n = 2^d - 1$, ונוכיח קיום עץ $T = \la V, E \ra$ כך ש־$|V| = n$. נבחר, $V = \N \cap [1, n]$, ונבנה את $E$ כך שה־root מתחבר לשני ילדיו, כל אחד מהילדים מתחבר לשני ילדים נוספים, וכן הלאה עד אשר מגיעים לילד ה־$d$, שם עוצרים. סה"כ בכל "שכבה" של ילדים יהיו $2^i$ צמתים (כי כל שכבה תתפצל ל־2 בהבאה), וסה"כ נגיע במדויק למספר הצמתים שהצבנו לנו: 
					\[\sum_{i = 1}^{d}2^i = 2^d - 1 = n = \sof{\N \cap [1, n]} = \sof{V}\]
					
					\textit{הערה: }בנייה מפורשת ופורמלית של $E$ אפשרית אך מיותרת בקונטסט זה. בנייה כזו נבנת כחלק מסעיף ג' בשאלה זו, אך ע"י אלגוריתם. 
					\item[$\impliedby$]
					נניח קיום $ d \in \N $ כך ש־$ 2^d - 1 = n $, נוכיח באינדוקציה על $ d $ קיום עץ מושלם.
					\begin{itemize}
						\item בסיס: $ d = 1 $ אזי $ n = 2^1 - 1 = 1 $ מושלם באופן ריק;
						\item צעד: נניח על $ d $ קיום $ n $ עץ מושלם, בעבור $ d' := d + 1 $ יוצב $ n' := 2^{d + 1} = 2^d + (2^d - 1)$, ונוכיח קיום עץ מושלם בעבור $n'$. ידוע על קיום עת בגודל $ n = 2^d - 1 $ מושלם מה.א., בהתאם לאינדוקציה מהסעיף הקודם יש לו $ 2^{n - 1} $ עלים, נבחר עץ עבורו לכל אחד מהעלים יש שני ילדים העונה על התנאים של עץ מושלם (בהתאם להגדרת מסלול ומה.א.) וסה"כ $ 2^n $ עלים כלומר ובהתאם כלומר $ n' = n + 1 $ וסיימנו. 
					\end{itemize}
					סה"כ הוכחנו את שתי הגרירות, כדרוש. 
				\end{itemize}
			\end{proof}
			\item עתה, יש להוכיח יחידות עץ זה. 
			\begin{proof}
				יהי $ n \in \N $, מהטענות לעיל קיים עץ בעל $ 2^n - 1 $ צמתים, נסמן את המסלול הארוך ביותר לכל העלים ב־$ l $. נניח בשלילה קיום עץ שונה ממנו, שנוכל לבטא כשינוי על העץ הקיים שלנו. נניח בשלילה שאפשר להזיז מספר אי זוגי של צמתים ונמצא כי יש עלה בעל ילד יחיד וזו סתירה, לכן נוכל להזיז מספר זוגי של צמתים בלבד. נזיז $ 2i $ צמתים, אם חזרנו לנקודת ההתחלה, סיימנו, אם לאו, אזי קיימת לפחות צומת אחת בעלת 2 עלים חדשים, ומכאן שהמסלול אליה הוא $ l + 1 $, וביאנדוקציה (לא אפרטה כי זה יחסית ברור מאליו) בהכרח קיימת צומת בעלת מסלול קצר יותר (ממנה "הבאנו את העלים") וזו סתירה. 
			\end{proof}
		\end{itemize}
		
		
		
		\item ננתח את סיבוכיות זמן הריצה של \ttt{build\_balanced}. בתוכה, יש לולאה העוברת על $n$ ה"שכבות" בעץ. כלומר, $i$ משתנה החזרה בין $1 \le i \le n$. כתלות ב־$i$, הלולאה בפנים תבצע $2^i$ קריאות ל־\ttt{BinarySearchTree.insert} \ כאשר זאת יקח סיבוכיות של $i$, כמות שכבות שכבר נוספה. סה"כ, נבצע $\sum_{i = 1}^{n}2^i \cdot i = \frac{n(n + 1)(n + 2)}{6} = \bm{\Theta(n^3)}$ פעולות. 
		\item נתח את סיבוכיות הפונקציה \ttt{subtree\_sum}. הפונקציה עוברת רקורסיבית מה־root לשני הצמתים אליה היא מחוברת, ומשום שאין מעגל בעץ בינארי לפי הגדרת עץ, אז נעבור על לא יותר מעל הצמתים בגרף. בגלל שיש קשר בין כל שני צמתים, אז נעבור לכל היותר על כל הצמתים בגרף. סה"כ נעבור בדיוק על כל הצמתים בגרף, ולא נבצע שום דבר פרט לקיראות רקורסיביות בסיבוכיות שאינה $O(1)$. משום שיש $n$ צמתים, סה"כ הגענו לסיבוכיות של $\bm{\Theta(n)}$. 
	\end{enumerate}
	\section{}
	\begin{enumerate}[A.]
		\skipitems{1}
		\item יהי $n$ אורך רשימה ו־$k$ אורך רישא וסיפא אותו נשווה. ננתח בעבור המקרה הגרוע, שיתרחש כאשר תמיד ה־suffix־ים וה־prefix־ים יהיו זהים (כי כך השוואת הרשימות מעולם לא תגיע לתנאי העצירה שלה, בו מתקבלים שני תווים שונים) כלומר $\forall i, j. s_i[:k] = s_j[-k:]$. במקרה הזה, ניכנס ללולאה שתעשה $n$ איטרציות, חיתוך ב־$O(k)$, ועוד $n$ איטרציות שיכללו חיתוך במחיר $O(k)$. סה"כ $O(n(k + nk)) = O(nk + n^2k) = \bm{O(n^2k)}$. 
		\skipitems{1}
		\item נניח שאין שתי מחרוזות עם אותו ה־prefix או ה־suffix, או שאלו שווים בין שתי מחרוזות, ונניח שהשוואת מחרוזות וחישוב hash מתבצע ב־$O(k)$ כאשר $k$ אורך המחרוזת. ראשית נכנס ללולאה שתבצע חיתוך ו־\ttt{insert}, שניהם ב־$O(k)$, ונקבל מכאן $O(2nk)$. בלולאה הבאה נחשב חיתוך ב־$O(k)$ ו־\ttt{hash} \ כחלק מפעולת \ttt{find}, שתיארך $O(k)$ גם היא. סה"כ גם כאן $O(2nk)$, ונקבל $O(4nk) = \bm{O(nk)}$. 
	\end{enumerate}
	\section{}
	\begin{enumerate}[A.]
		\item \begin{enumerate}[i]
			\item \textbf{מספר העלים בעץ }$\bm{H}$\textbf{: }ישנו עלה לכל תו: נניח בשלילה שלא כן, נפלג למקרים. אם מספר העלים גדול ממש ממספר התווים, אזי קיים עלה הנוצר מחיבור שני תווים (זו הדרך השנייה ליצור צומת לפי הגדרת עץ הפאמן) וזו סתירה לכך שהוא לא עלה. אחרת קיימים פחות תווים מעלים, כלומר קיים איזשהו תו שאינו עלה ומכאן שאינו בעץ, וזו סתירה. סה"כ התשובה היא $\bm{c = t}$. 
			\item \textbf{משקל השורש של העץ }$\bm{H}$\textbf{: }משקל השורש הוא (אפשר להוכיח באינדוקציה) חיבור ערכי כל האותיות בא"ב. כל אות נוספת בקורפוס תוביל להעלאת ערך אות כלשהי ב־1, ולכן התשובה היא $\bm{c = n}$. 
			\item \textbf{גובה העץ }$\bm{H}$\textbf{: }כפי שהוכח כאשר דיברנו על עצי חיפוש בינאריים, האורך המינימלי הוא בעבור $\log t + 1$ (כאשר העץ מאוזן, כמו בסעיף 1(ג)). עבור חסם עליון, העץ המקיסמלי האפשרי אורכו $t$ לפי הגדרה (עבור צורה כמו בסעיף 1(א)), והוכחנו את קיומו אם נבחר את הקורפוס להיות מספרי פיבונאצ'י. סה"כ $\bm{\log t + 1 \le c \le t}$. 
			\item \textbf{מספר הצמתים בעץ }$\bm{H}$\textbf{: }\textit{טענה: }$\bm{c = 2t - 1}$.
			\begin{proof}נוכיח באינדוקציה. בסיס, $t = 2$, העץ היחיד שיתכן הוא: 
				\begin{center} \begin{forest}
						for tree={draw, circle}
						[ab, l=3pt, [a][b]]
				\end{forest} \end{center}			וסה"כ $c = 3 = 2 \cdot 2 - 1 $ כדרוש. צעד: נניח באינדוקציה מלאה נכונות לעץ ל־$k < t$ תווים, ונוכיח בעבור עץ ל־$t$ תווים. משום ש־$t \ge 3 $ אזי נוכל לפלגו לשני תתים עצים לא ריקים עבור מספר תווים קטן ממש מ־$t$, שנסמן כי יש להם $c_1, c_2 $ תווים בהתאמה. סה"כ נחברם בצומת כמותאר בעץ האפמן (שהוא עץ בינארי), ונקבל $c = c_1 + c_2 + 1 $ תווים. נסמן את כמות התווים בהם $k_1, k_2 $, לפיכך $k_1 + k_2 = t$ וגם $c_1 =2k_1 - 1, c_2 = 2k_2 - 1 $ וסה"כ $c = 2(k_1 + k_2 - 1) + 1 = 2t - 1 $ כדרוש. 
			\end{proof}
			
		\end{enumerate}
		\item $\bm{\Delta := ||C(a_n)| - |(C(a_1))|| = 0}$.
		\begin{proof}
			כדי להוכיח את הטענה, נוכיח שהעץ בצורה של עץ מאוזן, כלומר: 
			\sen\begin{center} \begin{forest}
				for tree={math content}
				[a_1a_2a_3\dots a_n, name=A1
					[\ , name=B1, no edge, l=10pt, 
						[a_1a_2, name=A
							[a_1]
							[a_2]
						]
					[a_{n - 1}a_n, name=B
						[a_{n - 1}]
						[a_n]]
					]
				]
				\path (A) --(B) node[midway]{$\dots$};
				\path (A1) --(B1) node[above]{$\vdots$};
			\end{forest} \end{center} \she
		כבסיס, משום ש־$2|256$, אז נחלקם מהסדר $a_1 < \cdots < a_n$ הנתון בצורה של $\{a_1, a_2\}, \{a_3, a_4\}, \dots, \{a_{n - 1}, a_n\}$. זאת, כי בשום שלב לא יתכן שאיבר יחיד $a_i$ יהיה המינימום, כי לשם כך קיימים $a_{k}, a_{k + 1}$ כך ש־$a_k + a_{k + 1} < a_i$ אך ממונוטוניות $a_1 \le a_k, a_2 \le a_{k + 1}$, ולכן: 
		\[ a_n < 2a_1 < a_1 + a_2 \le a_k + a_{k + 1} \le a_i < a_n \]
		וסה"כ $a_n < a_n$ וזו סתירה. באינדוקציה, גם בעבור $a_i, a_{i + 1}, a_{i + 2}, a_{i + 3}$ יצתמדו עם $a_{i + 4}, \dots a_{i + 7}$, ובכלליות $a_{i} \dots a_{i + j}$ מוצמד עם $a_{i + j + 1}, a_{2j}$, כאשר $j \mid i$ ו־$\log j \in \N$, שני התנאים אפשריים כי $\log 256 \in \N$. סה"כ מהתנאים האלו קיבלנו עץ מאוזן. 
		
			משום שהוכח כי העץ עץ מאוזן, לפי הגדרה, אורך המסלול בין כל אחד מהעלים לשורש זהה, ובמקרה הזה, הוא $\log 256$. בפרט בעבור $a_n, a_1 $. אורך קידוד האפמן הוא אותו האורך, ולכן $\ell = u = \log256$, נעביר אגפים ונקבל $\bm{\ell - u = 0}$. 			
		\end{proof}
		\item \begin{enumerate}[1.]
			\item יהי c קוד חח"ע שאינו prefix-free ואינו uniquely-decodeable \del. יהיו שתי מחרוזות \ttt{text1, text2}. טענה שגוייה היא כי הדחיסה תניב בהכרח שתי מחרוזות בינאריות שונות. 
			\begin{proof}					נוכיח ע"י נתינת דוגמה נגדית. נבחר $C$ קוד על $\{a, b, c\}$, המוגדר לפי $C(a) = 01, C(b) = 0, C(c) = 001$. נראה כי הוא מקיים את תנאי הרישא של הגרירה. בבירור, הקוד חח"ע. הוא גם אינו prefix-free כי \ttt{C(a) == C(b) + "1"}. הוא גם אינו uniquely-decodeable כי עבור המחרוזת \ttt{001} \ ניתן יהיה לפרשה הן כ־\ttt{ba}\ והן כ־\ttt{c}. עתה נראה כי הדחיסה עלולה לפלוט תוצאות זהות עבור זוג מחרוזות שונה. נבחר \ttt{text1 = ba, text2 = c}. אין חזרות ולכן דחיסת LZW לא תבוא לידי ביטוי. סה"כ נקבל את המחרוזות בינאריות $0001, 0001 $ שהן זהות, וזו סתירה לטענה. 
			\end{proof}
			\item יהי $c$ קוד חח"ע שאינו prefix-free אך uniquely-decodeable \del. יהיו שתי מחרוזות \ttt{text1, text2}.
			\begin{proof}
				נוכיח כי הצפנתן שונה. המחרוזות שונות, ולכן קיים אינקס $i$ ב־\ttt{text1[i] != text2[i]} \ כלשהו שונה בניהן. נפלג למקרים.
				
			\end{proof}
		\end{enumerate}
	\end{enumerate}
\end{document}
