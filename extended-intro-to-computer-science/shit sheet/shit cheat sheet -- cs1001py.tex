%!!!
%COMPILE WITH LUALATEX!
%
%!!!

%! ~~~ Packages Setup ~~~ 
\documentclass[]{article}


% Math packages
\usepackage[usenames]{color}
\definecolor{deepred}{rgb}{0.5,0.03,0.02}

\usepackage{forest}
\usepackage{ifxetex,ifluatex,amsmath,amssymb,mathrsfs,amsthm,witharrows,mathtools}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}
\usepackage[thinc]{esdiff}


% tikz
\usepackage{tikz}
\newcommand\sqw{1}
\newcommand\squ[4][1]{\fill[#4] (#2*\sqw,#3*\sqw) rectangle +(#1*\sqw,#1*\sqw);}


% code 
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{codeblue}{rgb}{0,0,0.5}
\definecolor{codered}{rgb}{0.5,0.03,0.02}
\definecolor{codegray}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{pythonstylesheet}{
	language=Python,
	emphstyle=\color{deepred},
	backgroundcolor=\color{codegray},
	keywordstyle=\color{deepblue}\bfseries\itshape,
	numberstyle=\scriptsize\color{codenumber},
	basicstyle=\ttfamily\footnotesize,
	commentstyle=\color{codegreen}\itshape,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false, 
	tabsize=4, 
	morekeywords={as,assert,nonlocal,with,yield,self,True,False,None,AssertionError,ValueError,in,else},
	keywordstyle=\color{codeblue},
	emph={random,object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,print,range,xrange,append,execfile,real,imag,reduce,str,repr,__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,pow},          % Custom highlighting
	emphstyle=\color{codered},
	stringstyle=\color{codegreen},
	showstringspaces=false,
	abovecaptionskip=0pt,belowcaptionskip =0pt,
	framextopmargin=-\topsep, 
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\lstinline!#1!}}
\lstset{style=pythonstylesheet}

\usepackage[style=1,skipbelow=\topskip,skipabove=\topskip,framemethod=TikZ]{mdframed}
\definecolor{bggray}{rgb}{0.85, 0.85, 0.85}
\mdfsetup{leftmargin=0pt,rightmargin=0pt,innerleftmargin=15pt,backgroundcolor=codegray,middlelinewidth=0.5pt,skipabove=5pt,skipbelow=0pt,middlelinecolor=black,roundcorner=5}
\BeforeBeginEnvironment{lstlisting}{\begin{mdframed}\vspace{-0.4em}}
	\AfterEndEnvironment{lstlisting}{\vspace{-0.8em}\end{mdframed}}


% Design
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.4in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\forestset{default}

\renewcommand\labelitemi{$\bullet$}

\usepackage{titlesec}
\titleformat{\section}[block]
	{\fontsize{20}{20}}
	{\huge (\thesection) \Large \dotfill\; }
	{0em}
{\MakeUppercase}

\usepackage{graphicx}
\graphicspath{ {./} }


% Language Shortcuts
\newcommand\ts    {\textsuperscript}
\newcommand\del   {$ \!\! $}
\newcommand\ttt   {\texttt}

\newcommand\npage {\vfil {\hfil \textbf{\textit{Continue on the next page}} \hfil \vfil}}

\newcommand{\rn}[1]{
	\textup{\uppercase\expandafter{\romannumeral#1}}
}

\makeatletter
\newcommand{\skipitems}[1]{
	\addtocounter{\@enumctr}{#1}
}
\makeatother
\newcommand\fortitle[1] {\Large #1 \normalsize}


% We don't talk about this
\newcommand\back  {\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}
\newcommand\backa {\!\!\!\!\!}
\newcommand\backb { }


%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\text{, }}
\newcommand\defi  {\text{ definition}}
\newcommand\defis {\text{ definitions}}
\newcommand\given {\text{given }}
\newcommand\case  {\text{if }}
\newcommand\syx   {\text{ syntax}}
\newcommand\rle   {\text{ rule}}
\newcommand\other {\text{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathit{Ans.}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\newcommand\dom   {\mathrm{dom}}
\newcommand\Img   {\mathrm{Im}}
\newcommand\range {\mathrm{range}}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\logx  {\log x}
\newcommand\lnx   {\ln x}
\newcommand\cosx  {\cos x}
\newcommand\cost  {\cos \theta}
\newcommand\sinx  {\sin x}
\newcommand\sint  {\sin \theta}
\newcommand\tanx  {\tan x}
\newcommand\tant  {\tan \theta}
\newcommand\sex   {\sec x}
\newcommand\sect  {\sec^2}
\newcommand\cotx  {\cot x}
\newcommand\cscx  {\csc x}
\newcommand\sinhx {\sinh x}
\newcommand\coshx {\cosh x}
\newcommand\tanhx {\tanh x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\slh   {\overset{LH}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}
\newcommand\ol    {\overline}

\newcommand\mlcm  {\mathrm{lcm}}

\DeclareMathOperator{\sech}   {sech}
\DeclareMathOperator{\csch}   {csch}
\DeclareMathOperator{\arcsec} {arcsec}
\DeclareMathOperator{\arccot} {arcCot}
\DeclareMathOperator{\arccsc} {arcCsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth} 

\newcommand\dx    {\,\mathrm{d}x}
\newcommand\dt    {\,\mathrm{d}t}
\newcommand\dtt   {\,\mathrm{d}\theta}
\newcommand\du    {\,\mathrm{d}u}
\newcommand\dv    {\,\mathrm{d}v}
\newcommand\df    {\mathrm{d}f}
\newcommand\dfdx  {\diff{f}{x}}
\newcommand\dit   {\limhz \frac{f(x + h) - f(x)}{h}}

\newcommand\nt[1] {\frac{#1}{#1}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limh  {\lim_{x \to 0}}
\newcommand\limni {\lim_{x \to - \infty}}
\newcommand\limpmi{\lim_{x \to \pm \infty}}

\newcommand\ta    {\theta}
\newcommand\ap    {\alpha}

\renewcommand\inf {\infty}
\newcommand  \ninf{-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}
\newcommand\setn      {\{a_i\}^{2n}_{i = 1}}
\newcommand\setc[1]   {\{a_i\}^{#1}_{i = 1}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}
\newcommand\capain    {\bigcap_{i = 1}^{n} A_i}
\newcommand\capai[1]  {\bigcap_{i = 1}^{#1} A_i}
\newcommand\capiiai   {\bigcap_{i \in I} A_i}

\newcommand\xot       {x_{1, 2}}
\newcommand\ano       {a_{n - 1}}
\newcommand\ant       {a_{n - 2}}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\sof[1]    {\left | #1 \right |}
\newcommand\cl [1]    {\left ( #1 \right )}
\newcommand\csb[1]    {\left [ #1 \right ]}

\newcommand\bs    {\blacksquare}

%! ~~~ Document ~~~

\title{\vspace{-0.8cm}Extended Intro. To Computer Science -- Shit Cheat Sheet}
\author{\textbf{\textit{Shahar Perets $\sim$ 2024}}}
\date{\normalsize Made using free software, but not by Stallman's definitions}

\begin{document}
	\setlength{\abovedisplayskip}{0pt}
	\setlength{\belowdisplayskip}{2pt}
	\setlength{\abovedisplayshortskip}{0pt}
	\setlength{\belowdisplayshortskip}{0pt}
	
	\setlength{\columnseprule}{0.2pt}
	
	\section{\fortitle{Python Built-Ins}}Python built-in data types, functions and etc. 
	\begin{multicols}{2}
		
		\subsection{Built-in functions}
		
		\texttt{abs}: \texttt{\_\_abs\_\_()}, absolute value. \\
		\texttt{all(iterable)}: returns \texttt{True} if all elemnts of the iterable are true, or if the iterable is empty. \\
		\texttt{any(iterable)}: return \texttt{True} if exists true element in the iterable, nor the iterable is empty. \\
		\texttt{bin, hex, oct (int) -> str}: int $ \rightarrow $ string, with '0b'/'0o' etc. at the begining. \\
		\texttt{chr(int) -> str}: converts ascii to a char. Reverses \texttt{ord()}. \\
		\texttt{ord(str) -> int}: converts a char to ascii. Reverses \texttt{chr()}. \\
		\texttt{divmod(a, b) := (a // b, a \% b)} \\
		\texttt{eval}: evaluate the expression. \\
		\texttt{globals(), locals()}: radioactive. \\
		\texttt{hash(immutable) -> int} return the hash of immutable objects. \\
		\texttt{id(obejct)}: unique and constant identity which create for any object. \\
		\texttt{max, min(iterable, key:function=None)} or \texttt{(*args, key=None)} returns the max/min value after appling \texttt{key}, if exists. \\
		\texttt{sorted(iterable, key=None, reverse=False) -> list}: return a new sorted list form the iterms in iterable. 
		
		\subsection{Built-in Data Structures}
		\subsubsection{list}
		\textbf{complexity} \\
		copy, pop, insert, delete, iteration, slicing: $ \bm{O(n)} $ \\
		appened, pop last, get, set, len: $ \bm{O(1)} $ \\
		sorting: avg. $ \bm{O(n \logn)} $, worst case $ O(n^2) $ \\
		\textbf{methods} \\
		\texttt{append(any) -> None, extend(b: iterable) := \\ a[len(a):] = b := a += b, insert(i, object) -> None, pop(int) -> any, count(x) -> int, copy() -> list, reverse() -> None} \\
		\textit{(Note that \texttt{-> None} mostly means in-place)} 
		\subsubsection{dict}
		\textbf{complexity, avg. } \\
		copy, iteration: $ \bm{O(n)} $ \\
		k in d, get, set, del: $ \bm{O(1)} $ \\
		\textit{(For more see 4.4. hash table)} \\
		\textbf{methods} \\
		\texttt{\_\_init\_\_(iterable [opt.], **kwargs), keys(), values() -> iterable, items() -> iterable[tuple]} (keys and values combined)\texttt{, clear() -> None, copy() -> dict, \_\_init\_\_(iterable[iterable], **kwargs)}
		\subsubsection{set}
		\textbf{methods: }\texttt{pop, add, remove(elem), pop()} removes random value, \texttt{clear()}. \\
		\textbf{complexity: }\texttt{in, pop, add, remove}: avg. $ O(1) $, worst $ O(n) $. \textit{(For more see 4.4. hash table)}
		
		\subsection{special methods}
		\textit{assuming \_\_\{name\}\_\_ syx.} \\
		\textbf{init}: initialize, \textbf{repr}: repr(obj) / REPL representation of the object, str: str(obj) value, call: calling, getattr, setattr, delattr: x.obj, x.obj = x, del obj respectively, \textbf{len}: len(obj), \textbf{contains}(x): x in obj, \textbf{getitem, setitem, delitem}, missing: obj[key], obj[key] = val, del obj[key], obj[non-existent-key] respectively, add, sub, mul, truediv, floordiv, mod, pow (y): x + y, x - y, obj * y, x / y, x //y, obj \% y respectively, iadd, isub (y) etc.: obj + y, obj - y etc. (in-place), neg, pos, abs, int: -x, +x, abs(x), int(x) respectively, \textbf{eq}, ne, lt, le, gt, ge, bool (y): x == y, x != y, x < y, x <= y, x > y, x >= y, if x: [...] respectively, \textbf{hash}: hash(obj). \\
		\textit{Note that \texttt{object}'s defualt behaviour is to use \texttt{id(obj))} e.g. for \texttt{eq}, \texttt{hash} etc. } \\
		\textit{The most important methods are bolded. }
		
	\end{multicols}
	
	
	\section{\fortitle{Maths}}
	\begin{multicols}{2}
		
		\subsection{General}
		\textbf{Euclid's algo.: }$ \gcd(a, b) = \gcd(a, b \bmod a) $, $ \gcd(a, 0) = a $. \\
		\textbf{Fermat’s Little Theorem: }$ p $ is prime $ \implies \forall a \in [2, \dots, p - 1]: a^{p - 1} \bmod p = 1 $. $ Ferm_N $ denoted to be the set of all $ a^{N - 1}\bmod N \neq 1 $ ("fermat-witness"). \\
		\textbf{Prime Witnesses Groups: }let $ n $ be a number, $ Gcd_n := \{1 \! < \! a \! < \! N \mid \gcd(N, a) > 1\}, \ Fact_n = \{a \in \N \colon a \mid n\}$, then $ Fact_n \subseteq Gcd_n \subseteq Ferm_n $.  \\
		\textbf{Miller-Rabin algo.: }$ |Ferm_N| \ge \tfrac{N}{2}$ for every $ N $ composite (except for carmichael numbers, which are rare) \\
		\textbf{Pascal's rule: }$ \tbinom{b}{k} =  \tbinom{n - 1}{k - 1} + \tbinom{n - 1}{k} $ \\
		\textbf{Hashing to }$ \bm{m} $\textbf{-sized int.: }\texttt{hash(x) \% m} \\
		\textbf{A mod rule \scriptsize{(for Diffie-Hellman)}: }$ (g^a \bmod p)^b = (g^{ab} \bmod p) $
		
		\subsection{Master Theorem}
		let $ f \colon \R \to \R $ be an function, and let $ a \le 1, b >1 $ be constants, assuming $ T \colon \R_{\ge 0} \to \R, \ T(n) = a \cdot T\left (\tfrac{n}{b} \right ) + f(n)$, then: 
		\begin{enumerate}
			\item $ \exists \vepsi > 0. f(n) = O(n^{\log_b a - \vepsi}) $ \\ $\implies T(n) = \Theta(n^{log_b a}) $
			\item $ f(n) = \Theta(n^{\log_b a}) $ \\ $\implies T(n) = \Theta(n^{log_b a} \cdot \logn) $
			\item $ \exists \vepsi > 0. f(n) = \Omega(n^{\log_b a + \vepsi}) \land $ \\
			$\ \exists c>1, n_0 \ge 0. \forall n \ge n_0. a \cdot f(\tfrac{n}{b}) \le c \cdot f(n) $ \\
			$\implies T(n) = \Theta(f(n)) $
		\end{enumerate}
		\textit{Note that $ \mathit{\tfrac{n}{b}} $ could be $ \mathit{\lf \tfrac{n}{b} \rf} $ nor $ \mathit{\lc \tfrac{n}{b} \rc} $}
		
		\subsection{Rules for Sums of Series}
		\begin{alignat}{9}
			&\sum_{i = 1}^n i &&= \tfrac{1}{2}n(n + 1) &&= \Theta(n^2) \\
			&\sum_{i = 0}^{n} x^i &&= \tfrac{x^{n + 1} - 1}{x - 1} &&= \Theta(x^n)  &(x \neq 1) \\
			&\sum_{i = 0}^{\infty} x^i&&= (1 - x)^{-1} &&= \Theta(1) &(0 < x < 1) \\
			&\sum_{i = 1}^{n} i^2 &&= \tfrac{n(n + 1)(2n + 1)}{6} &&= \Theta(n^3) \\
			&\sum_{i = 1}^{n} \tfrac{1}{i} &&= \Theta(\logn) \\
			&\sum_{i = 1}^{n} i^3 &&= \tfrac{n^2(n + 1)^2}{4} &&= \Theta(n^4) \\
			&\sum_{i = 1}^{n}  \log i &&= \Theta(n\log n) \\
			&\sum_{i = 1}^n (ca_i &&\!\!+ b_i) = c \sum_{i = 1}^{n} a_i &&\!\!+ \sum_{i = 1}^{n}b_i \\
			&\sum_{i = 1}^{n} \Theta \big(&&\!\!\!\!\, f(i)\big) = \Theta \Bigg (\sum_{i = 1}^{n} &&\!\!\!\, f(i) \Bigg)
		\end{alignat}
		When their names are (1) Arithmetic, (2, 3) Geometric, (4) Square and (5) Hermonic series.
		
		\subsection{Asymptotic Barriers}
		\subsubsection{definition}
		\begin{itemize}
			\item $ f(n) = O(g(n)) $ iff $ \exists c, n_0 \ge 0. \forall n \ge n_0. \ f(n) \le c g(n) $
			\item $ f(n) = \Omega(g(n)) $ iff $ \exists c, n_0 \ge 0. \forall n \ge n_0. \ f(n) \ge c g(n) $
			\item $ f(n) = \Theta(g(n)) $ iff $ f(n) = O(g(n)) \land f(n) = \Omega(g(n)) $
		\end{itemize}
		
		\begin{multicols}{2}
			[\subsubsection{Hierarchy}]
			\begin{enumerate}
				\item $ \Theta(1) $ (constant)
				\item $ \Theta(\log \logn) $ 
				\item $ \Theta(\log_a n) \ [\forall a \ge 2] $ \\ (logarithmic)
				\item $ \Theta(\log^a n) \ [\forall a > 1] $ \\ (poly logarithmic)
				\item $ \Theta(\sqrt{n}) $ (square root)
				\item $ \Theta(n) $ (linear)
				\item $ \Theta(n \log n) $
				\item $ \Theta(n^2) $ (quadaric)
				\item $ \Theta(n^2 \log n) $
				\item $ \Theta(2^n) $ (exponential)
				\item $ \Theta(3^n) $ [etc.] (exponential)
				\item $ \Theta(n!) $ (factorial)
				\item $ \Theta(n^n) \leftarrow $ your code (pure bad)
			\end{enumerate}
		\end{multicols}
		\subsubsection{Other rules}
		\begin{gather*}
			f_1 = O(g_1) \land f_2 = O(g_2) \implies f_1 + f_2 = O(\max(g_1, g_2)) \\
			\forall a_0, a_1, \dots, a_k \in \R_+, k \ge 1. f(n) = a_0n^0 + \dots + a_kn^k = \Theta(n^k)
		\end{gather*}
		
		\subsection{Binary Operations}
		\subsubsection{Complexity}
		Let $ n, m, t \in \N $ be natural numbers, and $ a, b, c $ their bit size: \\
		\textbf{Multiplication, Division: }$ \approx O(ab) $ \\
		\textbf{Addition/Subtraction: }$ \Theta(\max\{a, b\}) $ \\
		\textbf{Floor division by 2: }(\texttt{n // 2}) $ O(a) $ \\
		\textbf{Integer Exponent: }(\texttt{a ** b}) $ O(\log b) $ multiplications \\ 
		\textbf{Modular Exponent: }(\texttt{n ** m \% t}) $ O(c^3) $ (assuming $ a = b = c $). 
		\subsubsection{Other bases}
		For number $ N $ in base $ b $ represented by $ a_ka_{k - 1} \dots a_1a_0 $, $ N $ would be $ N = a_k b^k + a_{k - 1}b^{k - 1} + \dots + a_2b + a_1 $. Hence, $ b^{k - 1} \le N \le b^k - 1 $, and $ k = \lf \log_b N \rf + 1 $. From this, for a number with $d$ digits in base $b$, will take at most $\lf d \log_cb \rf$ digits in base $c$ (assuming $b, c, c > 1$). 
	\end{multicols}
	
	
	\section{\fortitle{Algorithms}}
	\begin{multicols}{2}
		
		\subsection{Sorting \& Searching Algo.}
		\subsubsection{Merge Sort}
		\textbf{complexity: }$ \Theta(n \log n) $ (Assuming implementation without slicing)
		\subsubsection{Quicksort}
		\textbf{complexity: }best, avg.: $ O(n \log n) $, worst: $ O(n^2) $. Same as merge sort, with random pivot. 
		\subsubsection{Selection sort}
		For i in [0, n], find the minimum of lst[i:] and position it at the begining. Always $ O(n^2) $. Bad. No real usecase. 
		\subsection{Binary search}
		When an ordered list is given, find the middle, then repeat for the right/left side of it (larger/smaller). Takes $O(\logn)$
		
		\subsection{Number Theory Algo. }
		\subsubsection{Modular exponention \& Interating Square}
		\textbf{Complexity: }$ O(n^3) $, suppose \texttt{a, b, c} are $ n $-bit long. \\
		\textbf{Interating Square algo.: }same as the code below, but without the \texttt{\%c}.
		\begin{lstlisting}
def modpow(a, b, c): 
	result = 1
	while b > 0: 
		if b % 2 == 1: result = (result * a) % c
			a = a*a % c; b = b//2
			return result # = a**b%c = pow(a, b, c)\end{lstlisting}
		\subsubsection{pseudo-primes}
		Returns if $ N $ is prime with probability of $ 1 - 0.5^{a} $, by fermat's little theorm. $O(n^3)$. \textit{(code in the next page)}
		\pagebreak
		\begin{lstlisting}
def is_prime(N, tests): 
	for i in range(tests): 
		a = random.randint(2, N - 1)
		if pow(a, N - 1, N) != 1: # a in Ferm_n
			return False
			reutrn True\end{lstlisting}
		\subsubsection{GCD (Euclid Algo.)}
		\textbf{Complexity: }$ \approx 2 \log b $ iterations which is $ O(\log b) $ (WOLOG $ b \ge a $). 
		\begin{lstlisting}
def gcd(a, b): 
	if a < b: a, b = b, a # switch
		while b > 0: 
			a, b = b, a % b
			return a\end{lstlisting}
		
		\subsection{Other}
		\subsubsection{Diffie-Hellman Protocol}
		Let $ p $ be a large prime, and let $ 1 < g < p - 1 $ be a random integer. The algo.: 
		\begin{enumerate}
			\item $ f(x) = g^x \bmod p $ is a public key
			\item Person A chooses number $ a $
			\item Person B chooses number B
			\item A computes $ f(a) = g^a \bmod p $
			\item B computes $ f(b) = g^b \mod p $
			\item Each one sends the computed number to each other
			\item Compute $ f(a)^b = f(b)^a $ (according to some random theorm in the math section) 
		\end{enumerate}
	\end{multicols}
	
	
	\section{\fortitle{Data Structures}}
	\begin{multicols}{2}
		
		\subsection{Linked List}
		\textbf{Description: }Each node stores its value, and the next node location, \texttt{None} in case it's the last one. The linked list class stores the head of the list, and the size of the list. 
		\begin{center}
			\begin{tabular}{|c|c|c|} 
				\hline Operation & Linked list & built-in list \\ 
				\hline insertion after a given element & $ O(1) $ & \color{deepred}$ O(n) $ \\
				\hline insertion in a given index & \multicolumn{2}{c|}{$ O(n) $} \\
				\hline get / modify n\ts{th} elements & \color{deepred}$ O(n) $ & $ O(1) $ \\
				\hline Delete given prev. element & $ O(1) $ & \color{deepred}$ O(n) $ \\
				\hline Delete by given index & \multicolumn{2}{c|}{\color{deepred}$ O(n) $} \\
				\hline
			\end{tabular}
		\end{center}
		
		\subsection{Doubly-Linked List}	
		Each node saves the prev. and next node, and the D.L.L. class saves both the tail (last element) and the head (first element). This method allow us to implement the \textbf{rotate} method: given $ o \le k < m $, the $ i $\ts{th} node of the list will change place and become the $ (i + k) \bmod n $ node (e.g. for k = 2, $ 0 \to 2 $, $ -1 \to 1 $ etc.; +k means "right" rotation, -k -- "left"). 
		
		\subsection{Binary tree}
		Each node contains inforamtion about the next node in the right and left subtrees, and its value. The binary tree class conatains info. about the root and the size. Assuming the tree is balanced (deepest in $ \log n $), then insert, lookup and minimum takes $ \log n $ time. 
		
		\subsection{Hash table}
		For $ m $-sized hash table the hash function would be \texttt{hash(n) \% m}. For each hash value assinged a list, which contains all of the elements with the same hash value. On avg. $ \alpha = \tfrac{m}{n} $ ($ \alpha $ called the \textbf{load factor}). The \texttt{dict} keys and \texttt{set} build-in classes uses $ n $-sized hash table, means $ O(\tfrac{n}{n}) = O(1) $ on avg., worst case $ O(n) $ (happens when every key is hashed to the same value).
		\definecolor{deepred}{rgb}{0.5,0.03,0.02}
		
		\columnbreak
		\subsection{Generators}
		\subsubsection{Creation}
		\begin{lstlisting}
>>> def gen(*arg, **kwargs): yield val  # opt. 1
>>> print(type(gen), type(gen()))
<class 'function'> <class 'generator'>
>>> gen = (val for val in iterable)     # opt. 2
>>> type(gen)
<class 'generator'>\end{lstlisting}
		\subsubsection{Usage}
		To get the next item, use the \texttt{next(gen)} function. We'll get a \texttt{StopIteration} at the end of finite generators. e.g.:
		\begin{lstlisting}[emph={StopIteration,Traceback}]
>>> def gen(): yield 1; yield 2; yield 3
>>> g = gen()
>>> print(next(g), next(g), next(g))
1 2 3
>>> next(g)
Traceback [...] StopIteration\end{lstlisting}
		\subsubsection{Notes}
		A given generator has "finite delay" iff the time that takes to generate each item is finite.
		Generators can be used recursively. 
		
		\subsection{float}
		D.A.F.U.K. <an image of a cat> \\
		\textbf{Saving data: }
		For 64-bit float: \\
		sign[1 bit] + exponent[11 bits] + fraction[52 bits] \\
		\textbf{Compute: } $ (-1)^{sign} \cdot 2^{exponent - 2023} \cdot (1 + fraction) $ \\
		\textbf{Domain: }$ 0 \le exponent \le 2047, \ 0 \le fraction \le \sum_{52}^{i = 1} 2^{-i} = 1 - 2^{-52} $
		
		\subsection{String Representations}
		\textbf{ASCII: }7-bit fixed-length, \ttt{00} to \ttt{1F} / 0-31: nulls, \texttt{30} to \texttt{39} / 48-57: 0-9, \texttt{41}-\texttt{5A} / 65-90: A-Z, \texttt{61}-\texttt{7A} / 98-122: a - b (including). 
		
		\textbf{Unicode: }variable length code. Hebrew is between 1488-1514 (22 + 5 = 27). The ascii code above works for unicode too. 
		
	\end{multicols}
	
	\pagebreak
	\section{\fortitle{Text Compression}}
	\begin{multicols}{2}
		
		\subsection{Definitions for codes}
		$\set C \colon \{0, 1\}^\Sigma$ \textit{be a code;} \\
		\textbf{Univeral: }$\forall x. |C(x)| < |x|$ when $|x|$ is the raw (binary) length. \textit{There isn't a universal lossless compression scheme. }\\
		\textbf{Codewords: } $x$ is a codeword iff $x \in \Img(C)$ \\
		\textbf{Variable-length: } $\nexists n. \forall x \in \Img(C). |x| = n$ \\
		\textbf{Prefix-Free: }$\forall \tau, \gamma \in \Sigma. \tau \neq \gamma \!\!\!\implies\!\!\!\!$ $C(\tau)$ isn't a prefix of $C(\gamma)$. \\
		\textbf{Uniquely-decodable: }$\exists C\op \colon \{0, 1\}^n \to \Sigma^n$ such as $\forall x_0, \dots x_n \in \dom(C\op). C(C\op_0) = x_0, \dots, C(C\op_n) = x_n$. 
		
		\subsection{Compression codes}
		\subsubsection{Huffman}
		Create a Huffman tree from a given corpus: 
		\begin{enumerate}
			\item Create a priority queue formatted characters : int
			\item Extact 2 minimums
			\item Create a tree out of them
			\item Add the tree to the queue
			\item Goto 2, until you get one tree
		\end{enumerate}
		Then, each way (left/rigth) to go to a given character, is decoded to 0/1. 
		
		\subsection{Lempel-Ziv}
		Saves repotitions in format of \texttt{[m, k]} when $m$ is the offset backwards, and $k$ is the length of the repitation, e.g.: 
		\begin{lstlisting}[emph={LZW_compress}]
>>> LZW_compress("abcabcabc")
["a", "b", "c", [3, 6]]	\end{lstlisting}
		We denote $1 \le m \le W \land 1 \le k \le L$, when by default $W = 2095 = 2^{12} - 1, L = 31 = 2^{5} - 1$ (takes 12, 5 bits respectively). 
		
		While converting the above intermediate list to binary, we add \texttt{0} before each single ASCII character, and \texttt{1} before each \texttt{[m, k]} entry. Hence, assuming ASCII encoding is being used, the minimal length word compressing is $12 + 5 + 1$ bits ($\log W + \log L + 1$ for the prefix), when a given character takes $7$ (ASCII) $+ \; 1$ (prefix) bits. In general, \textbf{we'll compress when}: 
		\[ 8k > 1 + |W| + |L| + 1, (|X| = \lf \log_2 X \rf + 1) \]
		This following function is being used to find the maximum match within a $T$ text, when $p$ is the current index: 
		\begin{lstlisting}
def maxmatch(T, p, W=2**12-1, L=2**5-1): 
	n = len(T); m = k = 0
	for offset in range(1, min(p, W) + 1):
		match_len, j = 0, p-offeset
		while match_len < min(n - p, L) and \
				T[j+match_len] == T[p + match_len]
			match_len += 1
			if match_len > k: 
				k, m = match_len, offset
	return m, k	\end{lstlisting}
		
		
		
	\end{multicols}
	
	\dotfill
	\begin{center}
		\Large \textbf{I may have some mistakes}
	\end{center}
	\dotfill
	
	{\let\newpage\relax\maketitle}
	\begin{center}
		
		\small\textit{contact me: sheave.lariat-0h@icloud.com \& u/Sh\_Pe}
		
	\end{center}
	\maketitle
	
	
\end{document}