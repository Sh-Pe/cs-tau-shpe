%! ~~~ Packages Setup ~~~ 
\documentclass[]{article}


% Math packages
\usepackage[usenames]{color}
\usepackage{forest}
\forestset{default preamble={for tree={draw,=}
}}
\usepackage{ifxetex,ifluatex,amsmath,amssymb,mathrsfs,amsthm,witharrows,mathtools}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}
\usepackage[thinc]{esdiff}


% tikz
\usepackage{tikz}
\newcommand\sqw{1}
\newcommand\squ[4][1]{\fill[#4] (#2*\sqw,#3*\sqw) rectangle +(#1*\sqw,#1*\sqw);}


% code 
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{codeblue}{rgb}{0,0,0.5}
\definecolor{codered}{rgb}{0.5,0.03,0.02}
\definecolor{codegray}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{pythonstylesheet}{
	language=Python,
	emphstyle=\color{deepred},
	backgroundcolor=\color{codegray},
	keywordstyle=\color{deepblue}\bfseries\itshape,
	numberstyle=\scriptsize\color{codenumber},
	basicstyle=\ttfamily\footnotesize,
	commentstyle=\color{codegreen}\itshape,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false, 
	tabsize=4, 
	morekeywords={as,assert,nonlocal,with,yield,self,True,False,None,AssertionError,ValueError,in,else},              % Add keywords here
	keywordstyle=\color{codeblue},
	emph={object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,print,range,xrange,append,execfile,real,imag,reduce,str,repr,__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,},          % Custom highlighting
	emphstyle=\color{codered},
	stringstyle=\color{codegreen},
	showstringspaces=false,
	abovecaptionskip=0pt,belowcaptionskip =0pt,
	framextopmargin=-\topsep, 
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\lstinline!#1!}}
\lstset{style=pythonstylesheet}

\usepackage[style=1,skipbelow=\topskip,skipabove=\topskip,framemethod=TikZ]{mdframed}
\definecolor{bggray}{rgb}{0.85, 0.85, 0.85}
\mdfsetup{leftmargin=0pt,rightmargin=0pt,innerleftmargin=15pt,backgroundcolor=codegray,middlelinewidth=0.5pt,skipabove=5pt,skipbelow=0pt,middlelinecolor=black,roundcorner=5}
\BeforeBeginEnvironment{lstlisting}{\begin{mdframed}\vspace{-0.4em}}
	\AfterEndEnvironment{lstlisting}{\vspace{-0.8em}\end{mdframed}}


% Deisgn
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\renewcommand\labelitemi{$\bullet$}
\usepackage{titlesec}
\titleformat{\section}[block]
{\fontsize{15}{15}}
{\en{\dotfill \thesection \dotfill}}
{0em}
{\MakeUppercase}
\usepackage{graphicx}
\graphicspath{ {./} }


% Hebrew initialzing
\usepackage[bidi=basic]{babel}
\PassOptionsToPackage{no-math}{fontspec}
\babelprovide[main, import, Alph=letters]{hebrew}
\babelprovide[import]{english}
\babelfont[hebrew]{rm}{David CLM}
\babelfont[hebrew]{sf}{David CLM}
\babelfont[english]{tt}{Monaspace Xenon}
\usepackage[shortlabels]{enumitem}
\newlist{hebenum}{enumerate}{1}

% Language Shortcuts
\newcommand\en[1] {\begin{otherlanguage}{english}#1\end{otherlanguage}}
\newcommand\sen   {\begin{otherlanguage}{english}}
	\newcommand\she   {\end{otherlanguage}}
\newcommand\del   {$ \!\! $}
\newcommand\ttt[1]{\en{\footnotesize\texttt{#1}\normalsize}}

\newcommand\npage {\vfil {\hfil \textbf{\textit{המשך בעמוד הבא}}} \hfil \vfil \pagebreak}
\newcommand\ndoc  {\dotfill \\ \vfil {\begin{center} {\textbf{\textit{שחר פרץ, 2024}} \\ \scriptsize \textit{נוצר באמצעות תוכנה חופשית בלבד}} \end{center}} \vfil	}

\newcommand{\rn}[1]{
	\textup{\uppercase\expandafter{\romannumeral#1}}
}

\makeatletter
\newcommand{\skipitems}[1]{
	\addtocounter{\@enumctr}{#1}
}
\makeatother

%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\text{, }}
\newcommand\defi  {\text{ definition}}
\newcommand\defis {\text{ definitions}}
\newcommand\given {\text{given }}
\newcommand\case  {\text{if }}
\newcommand\syx   {\text{ syntax}}
\newcommand\rle   {\text{ rule}}
\newcommand\other {\text{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathit{Ans.}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\newcommand\dom   {\mathrm{dom}}
\newcommand\Img   {\mathrm{Im}}
\newcommand\range {\mathrm{range}}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\logx  {\log x}
\newcommand\lnx   {\ln x}
\newcommand\cosx  {\cos x}
\newcommand\cost  {\cos \theta}
\newcommand\sinx  {\sin x}
\newcommand\sint  {\sin \theta}
\newcommand\tanx  {\tan x}
\newcommand\tant  {\tan \theta}
\newcommand\sex   {\sec x}
\newcommand\sect  {\sec^2}
\newcommand\cotx  {\cot x}
\newcommand\cscx  {\csc x}
\newcommand\sinhx {\sinh x}
\newcommand\coshx {\cosh x}
\newcommand\tanhx {\tanh x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\slh   {\overset{LH}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}
\newcommand\ol    {\overline}

\newcommand\mlcm  {\mathrm{lcm}}

\DeclareMathOperator{\sech}   {sech}
\DeclareMathOperator{\csch}   {csch}
\DeclareMathOperator{\arcsec} {arcsec}
\DeclareMathOperator{\arccot} {arcCot}
\DeclareMathOperator{\arccsc} {arcCsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth} 

\newcommand\dx    {\,\mathrm{d}x}
\newcommand\dt    {\,\mathrm{d}t}
\newcommand\dtt   {\,\mathrm{d}\theta}
\newcommand\du    {\,\mathrm{d}u}
\newcommand\dv    {\,\mathrm{d}v}
\newcommand\df    {\mathrm{d}f}
\newcommand\dfdx  {\diff{f}{x}}
\newcommand\dit   {\limhz \frac{f(x + h) - f(x)}{h}}

\newcommand\nt[1] {\frac{#1}{#1}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limh  {\lim_{x \to 0}}
\newcommand\limni {\lim_{x \to - \infty}}
\newcommand\limpmi{\lim_{x \to \pm \infty}}

\newcommand\ta    {\theta}
\newcommand\ap    {\alpha}

\renewcommand\inf {\infty}
\newcommand  \ninf{-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}
\newcommand\setn      {\{a_i\}^{2n}_{i = 1}}
\newcommand\setc[1]   {\{a_i\}^{#1}_{i = 1}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}
\newcommand\capain    {\bigcap_{i = 1}^{n} A_i}
\newcommand\capai[1]  {\bigcap_{i = 1}^{#1} A_i}
\newcommand\capiiai   {\bigcap_{i \in I} A_i}

\newcommand\xot       {x_{1, 2}}
\newcommand\ano       {a_{n - 1}}
\newcommand\ant       {a_{n - 2}}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\sof[1]    {\left | #1 \right |}
\newcommand\cl [1]    {\left ( #1 \right )}
\newcommand\csb[1]    {\left [ #1 \right ]}

\newcommand\bs    {\blacksquare}

%! ~~~ Document ~~~

\author{שחר פרץ}
\title{תרגיל בית מספר 4 $\sim$ מבוא מורחב למדעי־המחשב}

\begin{document}
	\maketitle
	\section{} %//1
	\begin{enumerate}[A']
		\item נסכם את הממצאים בטבלה: (זמן בשניות)
		\begin{center}
			\sen\begin{tabular}{|c|c|c|c|}
				\hline $t=$ & $n=$ & \ttt{rand=True} & \ttt{rand=False} \\
				\hline $10$ & $10^0$ & $3.1019 \cdot 10^{-6}$ & $1.2795\cdot 10^{-6}$ \\
				\hline $5$ & $10^1$ & $3.6131\cdot10^{-5}$& $2.2674\cdot10^{-5}$ \\
				\hline $2$ & $10^2$ & $0.0004105$ & $0.000313$ \\
				\hline $2$ & $10^3$ & $0.00570$ & $0.00485$ \\
				\hline $1$ & $10^4$ & $0.0752$ & $0.0579$ \\
				\hline $1$ & $10^5$ & $0.9293$ & $0.6556$ \\
				\hline $1$ & $10^6$ & $9.54367$ & $7.9088$ \\
				\hline $1$ & $10^7$ & $120.3766$ & $111.65889$ \\
				\hline $1$ & $10^8$ & $1660.6307$ & $1466.0910$ \\
				\hline
			\end{tabular}
			\she
		\end{center}
		נשים לב, שבאופן קבוע, כמעט ללא תלות בגודל $n$, שימוש ב־quicksort עם אקראיות יותר מהיר מבאשר בלי. בחרתי את ערך ה־$t$ לקטון עד לכדי $1$ כאשר מגיעים לערכי $n$ גבוהים, כי ההפרש בין התוצאות קטן ולכן הדיוק גדל, ואין צורך במספר רב של ריצות. 
		\item נסכם את הממצאים בטבלה (זמן בשניות): 
		\begin{center}
			\sen\begin{tabular}{|c|c|c|c|}
				\hline $t=$ & $n=$ & \ttt{rand=True} & \ttt{rand=False} \\
				\hline $10$ & $10^0$ & $5.3730 \cdot 10^{-6}$ & $2.0479 \cdot 10^{-6}$ \\ 
				\hline $5$ & $10^1$ & $8.05937 \cdot 10^{-5}$ & $6.6903 \cdot 10^{-5}$ \\ 
				\hline $3$ & $10^2$ & $0.0005981$ & $0.00158$ \\ 
				\hline $2$ & $10^3$ & $0.0063425$ & $0.1328$ \\ 
				\hline $2$ & $10^4$ & $0.06749$ & $11.5116$ \\ 
				\hline
			\end{tabular}\she
		\end{center} 
		(לא הצלחתי להריץ עבור $n = 5$ בגלל מחסור ב־RAM, ובכל מקרה בשביל $n = 4$ כבר היה דרוש \ttt{sys.setrecursionlimit}). מהנתונים האלו נסיק כי באופן קבוע, כמעט ללת תלות בגודל $n$, שימוש ב־quicksort בלי אקראיות יותר מהיר מאשר עם. זאת כי באופן קבוע כאשר \ttt{rand=True} אז זמן הריצה קצר באופן משמעותי, כפי שאפשר לראות בטבלה. 
	\end{enumerate}
	
	\npage
	\section{} %//2
	\begin{enumerate}[A']
		\item 	\begin{enumerate}[i.]
			\item נסטט עץ (כמות הפעולות מצד ימין מטה לגודל הקלט שמתקבל)
			\begin{center}\sen\begin{forest}
					for tree = {
						llabel/.style={label={[label distance=-4pt]-30:#1}},
						edge path={
							\noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) [out=-90,in=90] to (.child anchor)\forestoption{edge label};
						},circle,
						parent anchor=south,
					}
					[$n$, llabel = $n$
						[$\frac{n}{2}$, llabel = $\frac{n}{2}$
							[$\frac{n}{4}$, llabel = $\frac{n}{4}$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
							[$\frac{n}{4}$, llabel = $\frac{n}{4}$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
						]
						[$\frac{n}{2}$, llabel = $\frac{n}{2}$
							[$\frac{n}{4}$, llabel = $\frac{n}{4}$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
							[$\frac{n}{4}$, llabel = $\frac{n}{4}$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
						]
					]
				\end{forest}\she\end{center}
			לפי העץ, בשכבה ה־i יהיו $2^{i}$ צמתים, בכל צומת $\frac{n}{2^i}$ פעולות, וסה"כ נקבל $\sum_{i = 1}^{\logn} 2^ii \cdot \frac{n}{2^i} = n \logn $ פעולות, כלומר הסיבוכיות של \ttt{max\_v1} תהיה $O(n \logn)$. 
			
			\item נסרטט עץ גם למקטע הקוד הזה: 
			\begin{center}\sen\begin{forest}
					llabel/.style={label={[label distance=-3pt]-80:#1}},
					for tree = {grow=east, circle}
					[$\ n \ $, llabel = $\ n$
					[$n - 1$, llabel = $n - 1$
					[$n - 2$, llabel = $n - 2$
					[$\ 1 \ $, edge=dashed, llabel = $\ 1$]
					]
					]
					]
				\end{forest}\she\end{center}
			כאן, יהיו $n$ node־ים בעץ, ב–node ה־$i$ יתבצעו $i$ פעולות, כלומר סה"כ הסיבוכיות של \ttt{max\_v2} \ תהיה $\sum_{i = 1}^{n}i = \frac{n^2 + n}{2} = \bm{O(n^2)}$. 
		\end{enumerate}
		\item ננתח את סיבוכיות זמן הריצה של הפונקציות המשופרות. 
		\begin{enumerate}[i.]
			\item הפעם, הסיבוכיות של כל צומת בעץ היא 1, כי חישוב מקסימום בין 2 מספרים, לקיחת אינדקס מרשימה ופעולות אריתמטיות – כולן לוקחות זמן ריצה קבוע. נצייר את העץ: 
					\begin{center}\sen\begin{forest}
					for tree = {
						llabel/.style={label={[label distance=-4pt]-30:#1}},
						edge path={
							\noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) [out=-90,in=90] to (.child anchor)\forestoption{edge label};
						},circle,
						parent anchor=south,
					}
					[$n$, llabel = $1$
						[$\frac{n}{2}$, llabel = $1$
							[$\frac{n}{4}$, llabel = $1$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
							[$\frac{n}{4}$, llabel = $1$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
						]
						[$\frac{n}{2}$, llabel = $1$
							[$\frac{n}{4}$, llabel = $1$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
							[$\frac{n}{4}$, llabel = $1$, for children={edge=dashed}
								[$1$, llabel = $1$]
								[$1$, llabel = $1$]
							]
						]
					]
				\end{forest}\she\end{center}
			הפעם, בשכבה ה־$i$ עדיין יהיו $2^i$ צמתים, אך בכל אחד מהם רק פעולה אחת, וסה"כ $\sum_{i = 0}^{\logn} 2^i = 2^{\logn + 1} - 1 = 2n - 1$. נקבל שסיבוכיות הפונקציה \ttt{max\_v1\_improved} \ תהיה $\bm{O(n)}$ – ליניארית, בהשוואה ל־\ttt{max\_v1} שסיבוכיותו הייתה $O(n \logn)$. 
			\item בכל קריאה רקורסיבית תתרחש קריאה רקורסיבית יחידה ל־$i - 1$, עד שמגיעים ל־$1$, דבר שתירחש לאחר $n - 1$ פעולות. עלותה של קריאה רקורסיבית במימוש החדש של \ttt{max\_v2\_improved} הוא קבוע, כלומר סה"כ נקבל סיבוכיות של $n - 1 = \bm{O(n)}$ – שהיא ליניארית, בהשוואה ל־$O(n^2)$ שארך ל־\ttt{max\_v2}. 
		\end{enumerate}
		\item הפונקציה עומדת בדרישות הסיבוכיות, כי בכל קריאה רקורסיבית מספר בערך $i$ היא תקרא לקריאה נוספת ב־$i - 1$ עד הדעה ל־$i = 1$, שעבור $i = n$ יארוך $n - 1$ קריאות. כל קריאה מתרחשת בזמן ריצה קבוע, שכן גישה לאינדקס ברשימה ופעולות אריתמטיות כולן קבועים, ולכן נקבל סיבוכיות $n - 1 = O(n)$ כדרוש. 
		
		\end{enumerate}
		
		\npage
		\section{} %//3
		\begin{enumerate}[A.]
			\skipitems{1}
			\item ידוע ש־$s$ ניתן לייצוג ע"י $O(\logn)$ ביטים, ולכן $s \le 2^{O(\logn)}$ כלומר קיים קבוע $c$ כך ש־$s \le 2^{c\logn} = 2^c \cdot 2^{\logn} = 2^cn = O(n)$ (כי $2^c$ קבוע). בפתרון הבעיה, אנו ניעזרים בממואיזה – כלומר, כל הקריאות שפשוט לוקחות ערך מהזכרון יהיו זניחות, ונוכל לחסום מלמעלה את הפתרון ע"י חישוב גודל הטבלה (כי כל קריאה רקורסיבית שדורשת חישוב שומרת ערך בטבלה). משום שלא נוסיף מקומות נוספים לזכרון מעבר למה שנוצר ב־wrapper, גודל הזכרון הוא חסם עליון לזמן הריצה. בחרנו בזכרון בגודל של $(s + 1) \times n$ כלומר $n \cdot (O(n) + 1)$, לכן קיים $a$ קבוע כך שהסיבוכיות תהיה $n \cdot (an + a) = an^2 + an = O(an^2) = \bm{O(n^2)}$, כדרוש. 
			\item נשווה את זמני הריצה. 
			\begin{center}\sen\begin{tabular}{|c|c|c|}
					\hline $n$ & \ttt{subset\_sum} & \ttt{subset\_sum\_efficient} \\
					\hline $3$ & $2.7021 \cdot 10^{-5}$ & $4.73389 \cdot 10^{-5}$ \\ 
					\hline $6$ & $9.9999 \cdot 10^{-5}$ & $6.08550 \cdot 10^{-5}$ \\ 
					\hline $9$ & $0.0007083$ & $0.00012372$ \\ 
					\hline $12$ & $0.0062107$ & $0.00018791$ \\ 
					\hline $15$ & $0.047123$ & $0.00028109$ \\ 
					\hline $18$ & $0.437716$ & $0.00038526$ \\ 
					\hline $21$ & $3.01997$ & $0.0003838$ \\ 
					\hline $24$ & $23.20511$ & $0.000440071$ \\ 
					\hline
			\end{tabular}\she\end{center}
			נשים לב שבגלל הסיבוכיות המערכית של הפונקציה הראשונה, הפונקציה השנייה בסיבוכיות הריבועית (שעולה הרבה יותר לאט) מהירה בהרבה, וההפרש גדל ככל שהקלט גדל – בכמה סדרי גודל. 
		\end{enumerate}
		
		\npage
		\section{} %//4
		\begin{enumerate}[A']
			\skipitems{1}
			\item \begin{enumerate}[i.]
				\item נצייר את עץ הרקורסיה הנדרש (כל הפעולות בזמן ריצה קבוע, ולא אוסיף label ליד הצמתים כדי לא להעמיס על הסרטוט):
				\begin{center}\sen\begin{forest}
					for tree = {
						llabel/.style={label={[label distance=-4pt]-30:#1}},
						edge path={
							\noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) [out=-90,in=90] to (.child anchor)\forestoption{edge label};
						},circle,
						parent anchor=south,
					}
					[$0 \ 3$
						[$1 \ 2$
							[$0 \ 1$
								[$1 \ 0$]
								[$2 \ 0$]
							]
							[$2 \ 1$
								[$3 \ 0$]
							]
						]
						[$2 \ 2$
							[$3 \ 1$
								[$0 \ 0$]
							]
						]
					]
				\end{forest}\she\end{center}
				\item צ.ל. קיום קלטים עבורם זמן הריצה אקפוננציאלי ב־$n$. 
				\begin{proof}
					למען הנוחות, לכל $n \in \N$, נסמן $[n] = \{k \in \N \mid 0 \le k < n\}$. ניגש להוכחה. נבחר $n_0 = 4$, ויהי $n \ge n_0$. נבחר $V = [n], |V| = n$, יהי $c \in \N \land 2 \le c < n$, ונבחר $E = [c] \times [c]$, $G = \la V ,E \ra$. כלומר, תת הגרף על $[c]$ ב־$G$ הוא קליקה. נמיר את הגרף למריצת השכנויות בהצגה של \ttt{list[list[int]]}, בגודל $n \times n$, כמתואר בשאלה. אזי, ונבחר $s = 0 \in [c], t = n - 1 \notin [c]$. נבחר $c = 3$, דבר שמתאפשר בהינתן $c < n < 4 = n_0$, ו־$t = n - 2 < n$. נקבל את עץ הרקורסיה הבא: 
					\begin{center}\sen\begin{forest}
							for tree = {
								llabel/.style={label={[label distance=-2pt]-10:#1}},
								edge path={
									\noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) [out=-90,in=90] to (.child anchor)\forestoption{edge label};
								}, 
								parent anchor=south,
							}
							[$0 \quad n - 2$, llabel=$1$,
								[$1 \quad n - 3$, llabel=$1$,
									[$0 \quad n - 4$, llabel=$1$,
										[$? \quad 1$, edge=dashed, llabel=$1$]
										[$? \quad 1$, edge=dashed, llabel=$1$]
									]
									[$2 \quad n - 4$, llabel=$1$,
										[$? \quad 1$, edge=dashed, llabel=$1$]
										[$? \quad 1$, edge=dashed, llabel=$1$]
									]
								]
								[$2 \quad n - 3$, llabel=$1$,
									[$0 \quad n - 4$, llabel=$1$,
										[$? \quad 1$, edge=dashed, llabel=$1$]
										[$? \quad 1$, edge=dashed, llabel=$1$]
									]
									[$1 \quad n - 4$
										[$? \quad 1$, edge=dashed, llabel=$1$]
										[$? \quad 1$, edge=dashed, llabel=$1$]
									]
								]
							]
					\end{forest}\she\end{center}
					יהיו $n$ שכבות בעץ הרקורסיה, כאשר בכל שכבה יש $2^i$ צמתים שדורשים סיבוכיות קבועה. נסכם; הסיבוכיות תהיה: 
					\[ \sum_{i = 1}^{n} 2^i = 2^{n} - 1 = \bm{O(2^n)} \]
					בהתאם לנדרש. 
				\end{proof}
				\end{enumerate}
			\item \begin{enumerate}[i.]
				\item עבור: 
				\sen\begin{lstlisting}
A = [[0, 0, 0] for _ in range(3)]
path_v2(A, 0, 1, 1)	\end{lstlisting}\she
				במקום לקבל \ttt{False} \ נקבל \ttt{RecursionError}, כי בכל קריאה רקורסיבית עבורה נניח $t = 1$, נקבל $mid = t//2 = 0 $ ולכן $ k - mid = 1 - 0 = 1$, כלומר תמיד תהיה קריאה רקורסיבית שתמשיך עם $k = 1$. 
				\skipitems{1}
				\item צ.ל. הפונקציה סופר־פולינומיאלית: 
				\begin{proof}
					נגדיר בדומה לסעיף הקודם $[n] := \N \cap [0, n), \implies |[n]| = n$. לכן, נוכל לבחור $V = [n], E = [n - 1] \times [n - 1], \ G = \la V, E \ra$. בחירה כזו חוקית לכל $n \ge 2 := n_0$. 
					נבנה את \ttt{A} \ מתוך הגרף כמתואר בשאלה, ע"י מציאת מטרצית השכנויות וייצוגה כרשימה דו־ממדית. נבחר $s = 0 \in [n], \ t = n - 1 \in [n] \setminus [n - 1]$ ו־$t = n - 1 < n$. משום שאין נתיב, הרצת הפונקציה \ttt{path\_v2(A, s, t ,k)} \ תיאלץ בהכרח לעבור כל הקריאות הרקוריסיבות שלה. בכל "שכבה" של עומק רקורסיה בעץ, נקבל $(n - 1)^{i}$ צמתים, ובגלל ש־$k$ קטן פי $2$ עד להיותו $1$ או $0$, הרקורסיה תיעצר רק לאחר $i = \logn$, כלומר בשכבה הנמוכה ביותר נקבל $(n - 1)^{\log(n - 1)}$ צמתים, שזה חסם תחתון סופר־פולינומיאלי מנתוני השאלה. סה"כ הוכחנו שהפונקציה סופר־פולינומיאלית. 
				\end{proof}
			\end{enumerate}
			\item \begin{enumerate}[i.]
				\item \begin{enumerate}[a.]
					\item \textbf{לא קיים} – החל מנקודת היציאה, הפונקציה תעבור על כל ההמשכים האפשריים, ובאינדוקציה תגיע בסופו של דבר לכל המסלולים האפשריים (תחת ההנחה שהיא מגיעה לכל האיטרציות, כלומר היא גומרת לרוץ, שמותר לנו להניח כי הנחנו בשלילה שהיא מחזירה \ttt{False}, כלומר מסתיימת). 
					\item \textbf{קיים} – עבור \ttt{A = [[1, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]} \ ו–\ttt{s = 0, t = 3}. 
					\item \textbf{לא קיים} – כאשר הפונקציה עוברת בין שני צמתים, היא תבדוק תקינות במטריצת השכנויות, כלומר לא יכול להיות שהיא תעבור במסלול לא תקין. 
					\item \textbf{קיים} – עבור \ttt{A = [[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]} \ ו–\ttt{s = 0, t = 3}. 
				\end{enumerate}
				\item הקוד משתמש בממואיזה עבור טבלה בגודל $n$, ולכן עם ידרוש מעל $n^2$ חזרות זו סתירה, כי זה אומר שניסינו לכתוב לטבלה מעל מה שנמצא בה (תוך ספירת הלולאה עצמה). הפתרון תקין, כי אם היינו במיקום מסויים ואז חזרנו אליו – אז המסלול מעגלי ולא יגיע ליעד, ולכן אפשר לסמן את הצומת ככזו שלא רלוונטית. 
			\end{enumerate}
		\end{enumerate}
		
		\npage
		\section{} %//5
		\begin{enumerate}[A']
			\item להלן עץ הרקורסיה של הקוד שלי כתלות בפרמטרים $s, start := s, 0$ (כי $L$ קבוע, ו־$start = 0$ כברירת מחדל). נניח $|L| = n$. נסמן $=:L_i$\ttt{L[i]}. 
			\begin{center}\sen\begin{forest}
				for tree = {
					llabel/.style={label={[label distance=-2pt]-10:#1}},
					edge path={
						\noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) [out=-90,in=90] to (.child anchor)\forestoption{edge label};
					},
					parent anchor=south,
				}
				[$s \quad 0$, llabel=$1$,
					[$s - L_0 \quad 1$, llabel=$1$,
						[$s - L_0 - L_1 \quad 2$, llabel=$1$,
							[$? \quad n$, edge=dashed, llabel=$1$,]
							[$? \quad n$, edge=dashed, llabel=$1$,]
						]
						[$s - L_0 + L_1 \quad 2$, llabel=$1$,
							[$? \quad n$, edge=dashed, llabel=$1$,]
							[$? \quad n$, edge=dashed, llabel=$1$,]
						]
					]
					[$s + L_0 \quad 1$, llabel=$1$,
						[$s + L_0 - L_1 \quad 2$, llabel=$1$,
							[$? \quad n$, edge=dashed, llabel=$1$,]
							[$? \quad n$, edge=dashed, llabel=$1$,]
						]
						[$s + L_0 + L_1 \quad 2$, llabel=$1$,
							[$? \quad n$, edge=dashed, llabel=$1$,]
							[$? \quad n$, edge=dashed, llabel=$1$,]
						]
					]
				]
				\end{forest}\she\end{center}
			יהיו $n$ שכבות, בכל אחת $2^i$ צמתים כמות הצמתים (גודל העץ) תהיה $\sum_{i = 1}^{n}2^i = \bm{2^{n} - 1} = O(2^n)$. 
			\item באופן דומה לסעיף הקודם, אך הפעם לא נצייר את $s$ שכן ערכו ארוך יותר במקרה זה ואין זה קובע את הסיבוכיות. 
			\begin{center}\sen\begin{forest}
				for tree = {
					llabel/.style={label={[label distance=-2pt]-10:#1}}, circle,
					parent anchor=south,
				}
				[0
					[1
						[2, for children={edge=dashed},
							[$n$]
							[$n$]
							[$n$]
							[$n$]
							[$n$]
						]
						[2 [\dots]]
						[2 [\dots]]
						[2 [\dots]]
						[2 [\dots]]
					]
					[1 [\dots]]
					[1 [\dots]]
					[1 [\dots]]
					[1
						[2 [\dots]]
						[2 [\dots]]
						[2 [\dots]]
						[2 [\dots]]
						[2, for children={edge=dashed},
							[$n$]
							[$n$]
							[$n$]
							[$n$]
							[$n$]
							]
						]
					]
				]
			\end{forest}\she\end{center}
		באופן דומה, גם כאן יש $i$ שכבות, אך הפעם $5^i$ צמתים בשכבה, כמות גודל עץ הרקורסיה יהיה: 
			\[ \sum_{i = 1}^{n}5^i = 1 \cdot \frac{5^n - 1}{5 - 1} \]
			שנחסם ע"י $O(5^n)$. 
			\item נבנה בתאם לפתרון נוסחת נסיגה: 
			\[ C_n = \sum_{i = 1}^{n}C_{n - i}C_{i} \]
			כאשר, תחת ההנחה שהאורך הוא $m$, נגדיר $n = \frac{m - 1}{2}$ (נוסחאת הנסיגה נכונה ישירות מהקוד, שבו יש לולאה שמבצעת את הקריאות הרקורסיביות הן $C_i, C_{n - i}$). נסתמך על העובדה שידוע פתרון לנוסחא הזו, הוא מספר קטלן. זאת, בהתאמה לעובדה שכמות האפשרויות למבני סוגריים מאוזנים מוגדרת (או נחשבת להגדרה מקובלת) להיות מספר קטלן. ידוע: 
			\[ C_n = \prod_{k = 2}^{n} \frac{n + k}{k} \ge \prod_{k = 2}^{n}\frac{n}{k} = \frac{2}{n!} \cdot n^{n - 1} = \Omega(n!) \]
		\end{enumerate}
		
		\npage
		\section{}
		\begin{enumerate}[A']
			\item צ.ל. 
			$ \forall n \in \Q. \exists p, q, \in \N. \gcd(p, q) \neq 1 \land \tfrac{p}{q} = n $, ובשלילה לוגית, באופן שקול $ \lnot(\exists n \in \Q. \forall p, q \in \N. \tfrac{p}{q}=n \implies \gcd(p, q) \neq 1) $ (לפי משפטי דה־מורגן על לוגיקה, הפיכת כמתים והגדרת גרירה). 
			\begin{proof}
				נניח בשלילה שקיים $ n \in \N $ כך שלכל $ p, q \in \Q $ אם $ \tfrac{p}{q} = n $ אז $  \gcd(p, q) \neq 1 $ (זה שקול לוגית לשלילה של הטענה, הצרנתית). משום ש־$ n \in \Q $ אז קיימים $ q, p \in \N $ כך ש־$ \tfrac{p}{q} = n $ (לפי הגדרה). נתבונן ב־$ \gcd(p, q) = c \neq 1 $, משום ש־$ \forall a, b \in \N. \gcd(a, b) \le 1 $ וטבעי, אז $ c \le 2 $. נוסף על כך, ידוע $ c \mid p \land c \mid q $ לפי הגדרת $ \gcd $, ונסמן $ p', q' = \tfrac{p}{c}, \tfrac{q}{c} \in \N $ בהתאמה, סה"כ $ \frac{p}{q} = \frac{\frac{p'}{c}}{\frac{q'}{c}} = \frac{p'}{q'} $. מהנחת השלילה, $ \gcd(p', q') := c' \neq 1 $, כלומר קיים $ c' \mid p' \land c' \mid q' $, ולכן $ c' \mid \tfrac{p}{c'} $ וגם $ c' \mid \tfrac{q}{c'} $. ידוע $ c' \in \N $. בהתאם לטענות הקודמות, $ G = c'c $ מקיים $ G \mid p \land G \mid q $, כלומר $ \gcd(p, q) \ge G $, סה"כ $ c \le c'c $ כלומר $ 1 \le c' $, בסתירה לכך ש־$ c' \le 2 $. סה"כ הנחת השלילה הוכחה כשגויה, וההוכחה הושלמה. 
			\end{proof}
		\end{enumerate}
		
		\npage
		\section{}
		סיכום התוצאות: 
		\begin{itemize}
			\item \textbf{הפונקציה \ttt{string\_to\_int}}: הבוט כשל. הקוד שלי מגדיר \ttt{n = len(s)}, כאשר נאמר לרובוט ובשאלה ש-$k$ הוא האורך של $s$, אך כתוצאה מהגדרה זו הבוט ראה שאני חוזר על $n$ וכתב: 
			\begin{center}\sen
				\textit{"Your implementation has a time complexity of O(n), while the correct time complexity is O(k)."}
				\she\end{center}
			למרות העובדה ש־$n$ בכלל לא מוגדר מחוץ לקוד שלי, ואין תלות בשני פרמטרים. 
			
			\textit{(אומנם זו בחירה לא טובה שלי של שמות משתנים, אך אין דבר פגם בקוד או בסיבוכיות שלו)}
			\item \textbf{הפונקציה \ttt{int\_to\_string}}: הקוד כתב, נכונה, שצדקתי והסיבוכיות מתאימה. 
			\item \textbf{הפונקציה \ttt{sort\_strings1}}: הקוד כתב, נכונה, שצדקתי והסיבוכיות מתאימה. 
			\item \textbf{הפונקציה \ttt{sort\_strings2}}: הקוד כתב, נכונה, שצדקתי והסיבוכיות מתאימה. 
		\end{itemize}
	בכל המקרים בהם הבוט כתב שצדקתי, הוא הסתייג בטענה שהוא עוזר AI ועלול לעשות טעויות. 
	
	לקונטקסט, הקוד שלי מצורף כאן: 
	\sen
	\begin{lstlisting}
# Q3_a
def char_to_int(c: str) -> int:
	"""helper for functions in Q11 (run in O(1))"""
	if c not in ["a", "b", "c", "d", "e"]:
		raise ValueError("only str a, b, c, d, e are allowed")
	else:
		return ord(c) - 97


def string_to_int(s: str) -> int:
	n: int = len(s)
	s = s[::-1]
	
	output: int = 0
	for i in range(n):
		output += 5 ** (i) * char_to_int(s[i])
	
	return output


# Q3_b
def int_to_char(i: int) -> str:
	"""helper for functions in Q11 (run in O(1))"""
	if i not in range(0, 5):
		raise ValueError("only intgers in range(1, 6) are allowed")
	else:
		return chr(i + 97)


def int_to_string(k: int, n: int) -> str:
	output = ""
	
	for i in range(k):
		scale = 5 ** (k - i - 1)
		output += int_to_char(
			n // scale
		)  # e.g. 69 // 25 = 2, then 19 // 5 = 3 and last 4 // = 4 => (2, 3, 4) = "bcd"
		remove = scale * (n // scale)  # equal to n % scale
		n -= remove
	
	return output


# Q3_c
def sort_strings1(lst: list[str], k: int) -> list[str]:
	"""sorts strings in alphabetic order"""
	n: int = len(lst)
	output: list[str] = []
	
	# create an empty list
	memory: list[list[int, str]] = [[0, ""] for _ in range(5**k)]  # exactly O(5**k)
	
	# assign to the `memory` the number of times that each value [=index] is shown in the list.
	for i in range(n):
		value = string_to_int(lst[i])  # exactly \Theta(kn)
		memory[value][0] += 1
		memory[value][1] = lst[i]
	
	# filling `output`
	for i in range(5**k):
		curVal: int = memory[i][0]  # exactly \Theta(5**k)
		if curVal == 0:
			continue
		
		revalue = memory[i][1]
		for _ in range(curVal):
			output.append(revalue)  # exactly \Theta(n)
	
	return output


# Q3_e
def sort_strings2(lst: list[str], k: int) -> list[str]:
	n = len(lst)
	output: list[str] = []
	
	for i in range(5**k):
		cur = int_to_string(k, i)
	for j in range(n):
		if lst[j] == cur:
			output.append(lst[j])
	
	return output\end{lstlisting}\she
	
	
\end{document}