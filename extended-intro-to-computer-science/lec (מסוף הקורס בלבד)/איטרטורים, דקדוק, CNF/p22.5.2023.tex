\documentclass[]{article}

% Math packages
\usepackage[usenames]{color}
\usepackage{forest}
\usepackage{ifxetex,ifluatex,amsmath,amssymb,mathrsfs,amsthm,witharrows}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}

% code 
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.5,0.03,0.02}

\lstdefinestyle{pythonstylesheet}{
	language=Python,
	morekeywords={}
	emphstyle=\color{deepred},
	backgroundcolor=\color{white},   
	commentstyle=\color{codegreen}\itshape,
	keywordstyle=\color{deepblue}\bfseries\itshape,
	numberstyle=\tiny\color{codenumber},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false, 
	tabsize=2, 
	morekeywords={object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,range,xrange,append,execfile,real,imag,reduce,str,repr},              % Add keywords here
	keywordstyle=\color{deepblue},
	emph={__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,as,assert,nonlocal,with,yield,self,True,False,None},          % Custom highlighting
	emphstyle=\color{deepred},
	stringstyle=\color{deepgreen},
	showstringspaces=false
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\pythonstyle\lstinline!#1!}}
\lstset{style=pythonstylesheet}


% Deisgn
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\forestset{default}
\renewcommand\labelitemi{$\bullet$}

% Hebrew initialzing
\usepackage{polyglossia}
\setmainlanguage{hebrew}
\setotherlanguage{english}
\newfontfamily\hebrewfont[Script=Hebrew, Ligatures=TeX]{David CLM}
\usepackage[shortlabels]{enumitem}
\newlist{hebenum}{enumerate}{1}
\setlist[hebenum,1]{
labelindent=\parindent,
label={{\hebrewfont{\protect\hebrewnumeral{\value{hebenumi}}}}.}
}


% Language Shortcuts
\newcommand\en[1] {\selectlanguage{english}#1\selectlanguage{hebrew}}
\newcommand\sen   {\selectlanguage{english}}
\newcommand\she   {\selectlanguage{hebrew}}
\newcommand\del   {$ \!\! $}
\newcommand\ttt[1]{\en{\texttt{#1}}}


%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\text{, }}
\newcommand\defi  {\text{ definition}}
\newcommand\defis {\text{ definitions}}
\newcommand\given {\text{given }}
\newcommand\case  {\text{if }}
\newcommand\syx   {\text{ syntax}}
\newcommand\rle   {\text{ rule}}
\newcommand\other {\text{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathit{Ans.}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\newcommand\dom   {\text{dom}}
\newcommand\Img   {\text{Im}}
\newcommand\range {\text{range}}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\cosx  {\cos x}
\newcommand\sinx  {\sin x}
\newcommand\tanx  {\tan x}
\newcommand\dx    {\,\mathrm{d}x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}

\newcommand\mlcm  {\mathrm{lcm}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limni {\lim_{x \to - \infty}}

\renewcommand\inf {\infty}
\newcommand\ninf  {-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}

\newcommand\sof[1]    {\left | #1 \right |}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\bs    {\blacksquare}

%! ~~~ Document ~~~


\author{שחר פרץ}
\title{מ.מ.למדמ"ח $\sim$ סיכום 22.5.2023}
\date{22 במאי 2024}

\begin{document}
\maketitle

\section{קצת על איטרטורים}
גנרטור: אויבטטק שמייצר איברים. בפייתון, ממומש ע"י פונקציה. הפונקציה מממשת את זה באמצעות הרצת קוד בעבור חישוב כל ערך שהיא מחזירה. בפייתון: נשתמש ב־yield. פונקציית גנרטור מחזירה גנרטור. 

בעת השמה ללואת for אובייקט משוג כלשהו, הוא קורא לפונקציה iter שנבקשת מהאבוייקט להחזיר איטרטור. אם היינו שמים בו גנרטור, אז היה מוחזר גנרטור. אם היינו שמים רשימה, הוא היה מחזיר "איטרטור של הרשימה" – איזשהו אירטור שמשתמש ברשימה, ומאחסן רק את האינדקס בתוכו. הלולאה תעצור כאשר היא תקבל StopIteration. היא למעשה while עד שהאיטרטור נגמר (באופן שקול). 

למעשה: 
	\sen
	\begin{lstlisting}
		for x in [1, 2, 3]: print (x) 
			i = iter([1, 2, 3]) 
		# is like
		while True: 
			try: 
				x = next(i)
			exepct StopIteration: 
				break
		print(x)
	\end{lstlisting}
	\she
	הפונקציה iter קוראת למתודה \_\_iter\_\_ \del. 
	כדאי לציין שהחל מ־python 3 יתקיים ש־dict שומר על סדר ההכנסה. 
	הערה: אפשר לעשות: 
	\sen
	\begin{lstlisting}
		for x in L := [1, 2, 3]: 
			print(x)
			L.pop()\end{lstlisting}
	\she
	וזה ישנה את ערך x בהתאם. \textbf{מוסכן לשנות את האובייקט שחוזרים עליו על ה-runtime} כי זה רעיון רע. 
	
	עבור dict, לדוגמה: 
	\sen
	\begin{lstlisting}
		D = {1: 1, 2: 2}
		for x in D: 
			print(x)
			D.pop()\end{lstlisting}
	\she
	אז יקפוץ RunTimeError \del.
	
	סה''כ, גם אם חייבים לשנות אובייקטים בזמן חזרה, תיהיו בטוחים מה אתם עושים ותיזהרו מאוד. 
	
	\section{דקדוק (Grammar)}
	בעת הרצת קוד פייתון, האינטרפטר מפרש את הקוד שכתוב. הדבר הראשון שנעשה הוא בדיקת הסינטקס, שהוגדר בעבור השפה. יש דקדוק פורמלי של השפה. הדקדוק מגדיר את השפה, ומגדיר את החוקים עבורם יתפרשו המשפטים. 
	הדקדוק מגדיר את השמפטים (תוכניות) החוקיים בשפה מבינה מבנית. 
	
	בהינתן קלט, האינטרפטר צריך להחליט/להבין האם הקוד תקין מבנית. 
	
	בגדול, דקדוק מוגדר ע''י: 
	\begin{enumerate}
		\item משתנים (Variables)\del \ : V
		\item א''ב (alphabet/Terminals) \del\ : $\Sigma$
		\item כללי היסק/גזירה (Rules)\del \ : R
		\item מתשני התחלה (start-variables)\del \ : S
	\end{enumerate}
	דוג': 
	\begin{gather*}
		G_1 \colon (V, \Sigma, R, S) \\
		V \colon \{A, B\} \\
		\Si \colon  \{0, 1, \#\} \\
		R_1: \begin{matrix}
			A &\to &0A1\\
			A &\to &B \\
			B &\to &\#
		\end{matrix} \\
		S \colon A
	\end{gather*}
	איך מייצרים מילה מתוך דקדוק? \\
	מתחילים במשתנה ההתחלה. \\
	כל עוד יש בידנו משתנים: 
	\begin{itemize}[-]
		\item נבחר משתנה שישש לנו
		\item נבח רכלל גזירה עבורו
		\item נפעיל את כלל הגזירה
	\end{itemize}
	לדוגמה: 
	$S \to A = 0A1 = 0B1 = 0\#1 $
	
	נסמן ב־$L(G)$ את אוסף המילים החוקיות ע''פ הדקדוק. נסמן מילה חוקית $W$ ע''י $w \in L(G)$. בדוגמה הזו, ניתן להגיד $''0\#1'' \in L(G)$. 
	$:L(G)$ השפה שמוגדרת ע''י הדקדוק $G$
	
	במקרה הזה, $L(G_1) = \{0^n\#1^n \mid n \in \N\}$. 
	
	\begin{align}
		G_2 &\colon (V, \Si, R, S)\\
		V &= \{S\} \\
		\Si &= \{a, b\} \\
		R &\colon \begin{matrix}
			S &\to &aSb \\
			S &\to &SS \\
			S & \to &\epsi
		\end{matrix}
	\end{align}
	כאשר $\epsi$ היא המחרוזת הריקה. 
	דוגמאות: 
	\[ ab \in L(G_2), \ aaabbb \in L(G_2), \ abab \in L(G_2) \ \epsi \in L(G_2) \]
	ובכלליות: אם נגדיר $a = (, b = )$ נקבל את מספר הקומבינציות החוקיות של סוגריים. 
	
	דוגמה אחרונה: 
	\begin{align*}
		G_3 &\colon (V, \Si, R, S) \\
		V &=\{S\} \\
		\Si &= \{x, y, z, \times, +\} \\
		R &\colon \begin{matrix}
			S &\to &S * S \\
			S &\to &S + S \\
			S &\to & \times \\
			S &\to & y \\
			S &\to & z
		\end{matrix}
	\end{align*}
	לדוגמה: 
	\[ x \times y + z \in L(G_3), \ x+ y \in L(G_3), x+ x + x + x \in L(G_3) \]
	הוכחה שהדוגמה הראשונה תקינה: 
	
	\hfil
	\begin{forest}
		[S 
			[S  [x]]
			[$\times$]
			[S [[S [y]] [+] [S [z]]]]
		]
	\end{forest}
	\hfil
	\begin{forest}
		[S 
			[S  [[S [x]] [$\times$] [S [y]]]]
			[+]
			[S [z]]
		]
	\end{forest}
	\hfil
	
	כלומר השפה אמביציונית (ambigous) \ \del \del; ניתן לגזור מילה במס' דכי גזירה שונים. 
	
	כל הדקדוקים שראינו הם ממשפחה הקרוייה ``דקדוקים חסרי הקשר'' – contect free grammer – CFG \del. 
	
	דקדוקים אלו מטילים מגבלה כלשהי: בכל כלל גזירה, בצד שמאל יופיע משתנה יחיד, שמופיע פעם אחת. בדקדוקים אלו אין צורך להתבונן במה קדם לתו שאנו נמצאים בו. דוגמא לדקדוק שאינו כזה: $aS \to ab, Sb \to aa$. 
	
	דקדוק חסר הקשר כל כללי הגזירה נראים $A \to \dots$. 
	\subsection{שאלות}
	נגיד ש־$G_1 $, $G_2 $ דקדוקים חסרי הקשר. 
	\begin{itemize}[-]
		\item האם $L(G_1) = L(G_2)$? $\iff$ האם הדקדוקים מגדירים את אותה השפה?
		\item האם $L(G_1) \subseteq L(G_2)$? $\iff$ האם השפה המוגדרת ע''י $G_2$ מכילה את השפה שמוגדרת ע''י $G_1$?
		\item האם $L(G_1) \cap L(G_2) \neq \emptyset$? $\iff$ האם יש חיתוך בין שתי השפות?
		\item האם קיימת מילה בשפה עבורה יש שני עצי גזירה שונים? $\iff$ האם הדקדוק הוא אמביציוני?
	\end{itemize}
	4 השאלות האלו לא ניתנות לחישוב. פרט לגודל האינסופי של $L(G)$, אי אפשר לפתח אלגוריתם המבצע השוואה בין החוקים, בכל המקרים. 
	
	שאלות שכן אפשר לענות עליהן: 
	\begin{itemize}[-]
		\item בהינתן דקדוק חסר הקשר $G$ ומילה $w$, האם $w \in L(G)$? 
		\item בהינתן דקדוק חסר הקשר $G$ ומילה $w \in L(G)$, למצוא עץ גזירה כלשהו של $w$ מ־$G$. 
	\end{itemize}
	
	את השאלות האלו אפשר לפתור באופן יעיל. 
	
	\textit{רעיון: }ננסה לעבור על כל הגזירות האפשריות. \\
	\textit{בעיה: }כאשר $w \not\in L(G)$, התהליך יכול לא לעצור. אין כלל עצירה טוב. \\
	
	\textit{פתרון: }נמיר את הדקדוק צורה שנקראת CNF – Chomsky-Normal-Form \del, שבה קל יותר לענות על השאלות האלה. כל דקדוק חסר הקשר ניתן לכתיבה בצורת CNF \del. 
	
	\subsection{CNF}
	בצורת CNF מותרים כללי גזירה מהצורה הבאה: 
	\begin{alignat*}{9}
		&A \to A &&\quad\quad A \in C, A \in \Si, \\
		&A \to BC &&\quad\quad A, B, C \in V \\
		&S \to \epsi
	\end{alignat*}
	איך נמיר דקדוק לכזה?
	\[ \begin{WithArrows}
		A &\to BCD \Arrow{\ } \\
		A &\to B A^*, A^* \to CD
	\end{WithArrows} \]
	
	\[ \begin{WithArrows}
		A &\to \epsi \Arrow{\ } \\
		A &\to S, S \to \epsi 
	\end{WithArrows} \]
	
	\[ \begin{WithArrows}
		A &\to aA \Arrow{\ } \\
		A &\to BA, B \to a
	\end{WithArrows} \]
	
	למעשה, כלל גזירה של מילה, הוא בהכרח עץ בינארי. 
	

\end{document}