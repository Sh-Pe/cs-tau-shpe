%! ~~~ Packages Setup ~~~ 
\documentclass[]{article}


% Math packages
\usepackage[usenames]{color}
\usepackage{forest}
\usepackage{ifxetex,ifluatex,amsmath,amssymb,mathrsfs,amsthm,witharrows,mathtools}
\WithArrowsOptions{displaystyle}
\renewcommand{\qedsymbol}{$\blacksquare$} % end proofs with \blacksquare. Overwrites the defualts. 
\usepackage{cancel,bm}
\usepackage[thinc]{esdiff}


% tikz
\usepackage{tikz}
\newcommand\sqw{1}
\newcommand\squ[4][1]{\fill[#4] (#2*\sqw,#3*\sqw) rectangle +(#1*\sqw,#1*\sqw);}


% code 
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.35,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codenumber}{rgb}{0.1,0.3,0.5}
\definecolor{codeblue}{rgb}{0,0,0.5}
\definecolor{codered}{rgb}{0.5,0.03,0.02}
\definecolor{codegray}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{pythonstylesheet}{
	language=Python,
	emphstyle=\color{deepred},
	backgroundcolor=\color{codegray},
	keywordstyle=\color{deepblue}\bfseries\itshape,
	numberstyle=\scriptsize\color{codenumber},
	basicstyle=\ttfamily\footnotesize,
	commentstyle=\color{codegreen}\itshape,
	breakatwhitespace=false, 
	breaklines=true, 
	captionpos=b, 
	keepspaces=true, 
	numbers=left, 
	numbersep=5pt, 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false, 
	tabsize=4, 
	morekeywords={as,assert,nonlocal,with,yield,self,True,False,None,AssertionError,ValueError,in,else},              % Add keywords here
	keywordstyle=\color{codeblue},
	emph={object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,print,range,xrange,append,execfile,real,imag,reduce,str,repr,__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,},          % Custom highlighting
	emphstyle=\color{codered},
	stringstyle=\color{codegreen},
	showstringspaces=false,
	abovecaptionskip=0pt,belowcaptionskip =0pt,
	framextopmargin=-\topsep, 
}
\newcommand\pythonstyle{\lstset{pythonstylesheet}}
\newcommand\pyl[1]     {{\lstinline!#1!}}
\lstset{style=pythonstylesheet}

\usepackage[style=1,skipbelow=\topskip,skipabove=\topskip,framemethod=TikZ]{mdframed}
\definecolor{bggray}{rgb}{0.85, 0.85, 0.85}
\mdfsetup{leftmargin=0pt,rightmargin=0pt,innerleftmargin=15pt,backgroundcolor=codegray,middlelinewidth=0.5pt,skipabove=5pt,skipbelow=0pt,middlelinecolor=black,roundcorner=5}
\BeforeBeginEnvironment{lstlisting}{\begin{mdframed}\vspace{-0.4em}}
	\AfterEndEnvironment{lstlisting}{\vspace{-0.8em}\end{mdframed}}


% Deisgn
\usepackage[labelfont=bf]{caption}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage[skip=4pt, indent=0pt]{parskip}
\usepackage[normalem]{ulem}
\forestset{default}
\renewcommand\labelitemi{$\bullet$}
\usepackage{titlesec}
\titleformat{\section}[block]
{\fontsize{15}{15}}
{\sen \dotfill (\thesection) \she}
{0em}
{\MakeUppercase}
\usepackage{graphicx}
\graphicspath{ {./} }


% Hebrew initialzing
\usepackage[bidi=basic]{babel}
\PassOptionsToPackage{no-math}{fontspec}
\babelprovide[main, import, Alph=letters]{hebrew}
\babelprovide[import]{english}
\babelfont[hebrew]{rm}{David CLM}
\babelfont[hebrew]{sf}{David CLM}
\babelfont[english]{tt}{Monaspace Xenon}
\usepackage[shortlabels]{enumitem}
\newlist{hebenum}{enumerate}{1}

% Language Shortcuts
\newcommand\en[1] {\begin{otherlanguage}{english}#1\end{otherlanguage}}
\newcommand\sen   {\begin{otherlanguage}{english}}
	\newcommand\she   {\end{otherlanguage}}
\newcommand\del   {$ \!\! $}
\newcommand\ttt[1]{\en{\footnotesize\texttt{#1}\normalsize}}

\newcommand\npage {\vfil {\hfil \textbf{\textit{המשך בעמוד הבא}}} \hfil \vfil \pagebreak}
\newcommand\ndoc  {\dotfill \\ \vfil {\begin{center} {\textbf{\textit{שחר פרץ, 2024}} \\ \scriptsize \textit{נוצר באמצעות תוכנה חופשית בלבד}} \end{center}} \vfil	}

\newcommand{\rn}[1]{
	\textup{\uppercase\expandafter{\romannumeral#1}}
}

\makeatletter
\newcommand{\skipitems}[1]{
	\addtocounter{\@enumctr}{#1}
}
\makeatother

%! ~~~ Math shortcuts ~~~

% Letters shortcuts
\newcommand\N     {\mathbb{N}}
\newcommand\Z     {\mathbb{Z}}
\newcommand\R     {\mathbb{R}}
\newcommand\Q     {\mathbb{Q}}
\newcommand\C     {\mathbb{C}}

\newcommand\ml    {\ell}
\newcommand\mj    {\jmath}
\newcommand\mi    {\imath}

\newcommand\powerset {\mathcal{P}}
\newcommand\ps    {\mathcal{P}}
\newcommand\pc    {\mathcal{P}}
\newcommand\ac    {\mathcal{A}}
\newcommand\bc    {\mathcal{B}}
\newcommand\cc    {\mathcal{C}}
\newcommand\dc    {\mathcal{D}}
\newcommand\ec    {\mathcal{E}}
\newcommand\fc    {\mathcal{F}}
\newcommand\nc    {\mathcal{N}}
\newcommand\sca   {\mathcal{S}} % \sc is already definded
\newcommand\rca   {\mathcal{R}} % \rc is already definded

\newcommand\Si    {\Sigma}

% Logic & sets shorcuts
\newcommand\siff  {\longleftrightarrow}
\newcommand\ssiff {\leftrightarrow}
\newcommand\so    {\longrightarrow}
\newcommand\sso   {\rightarrow}

\newcommand\epsi  {\epsilon}
\newcommand\vepsi {\varepsilon}
\newcommand\vphi  {\varphi}
\newcommand\Neven {\N_{\mathrm{even}}}
\newcommand\Nodd  {\N_{\mathrm{odd }}}
\newcommand\Zeven {\Z_{\mathrm{even}}}
\newcommand\Zodd  {\Z_{\mathrm{odd }}}
\newcommand\Np    {\N_+}

% Text Shortcuts
\newcommand\open  {\big(}
\newcommand\qopen {\quad\big(}
\newcommand\close {\big)}
\newcommand\also  {\text{, }}
\newcommand\defi  {\text{ definition}}
\newcommand\defis {\text{ definitions}}
\newcommand\given {\text{given }}
\newcommand\case  {\text{if }}
\newcommand\syx   {\text{ syntax}}
\newcommand\rle   {\text{ rule}}
\newcommand\other {\text{else}}
\newcommand\set   {\ell et \text{ }}
\newcommand\ans   {\mathit{Ans.}}

% Set theory shortcuts
\newcommand\ra    {\rangle}
\newcommand\la    {\langle}

\newcommand\oto   {\leftarrow}

\newcommand\QED   {\quad\quad\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\QEF   {\quad\quad\mathscr{Q.E.F.}}
\newcommand\eQED  {\mathscr{Q.E.D.}\;\;\blacksquare}
\newcommand\eQEF  {\mathscr{Q.E.F.}}
\newcommand\jQED  {\mathscr{Q.E.D.}}

\newcommand\dom   {\mathrm{dom}}
\newcommand\Img   {\mathrm{Im}}
\newcommand\range {\mathrm{range}}

\newcommand\trio  {\triangle}

\newcommand\rc    {\right\rceil}
\newcommand\lc    {\left\lceil}
\newcommand\rf    {\right\rfloor}
\newcommand\lf    {\left\lfloor}

\newcommand\lex   {<_{lex}}

\newcommand\az    {\aleph_0}
\newcommand\uaz   {^{\aleph_0}}
\newcommand\al    {\aleph}
\newcommand\ual   {^\aleph}
\newcommand\taz   {2^{\aleph_0}}
\newcommand\utaz  { ^{\left (2^{\aleph_0} \right )}}
\newcommand\tal   {2^{\aleph}}
\newcommand\utal  { ^{\left (2^{\aleph} \right )}}
\newcommand\ttaz  {2^{\left (2^{\aleph_0}\right )}}

\newcommand\n     {$n$־יה\ }

% Math A&B shortcuts
\newcommand\logn  {\log n}
\newcommand\logx  {\log x}
\newcommand\lnx   {\ln x}
\newcommand\cosx  {\cos x}
\newcommand\cost  {\cos \theta}
\newcommand\sinx  {\sin x}
\newcommand\sint  {\sin \theta}
\newcommand\tanx  {\tan x}
\newcommand\tant  {\tan \theta}
\newcommand\sex   {\sec x}
\newcommand\sect  {\sec^2}
\newcommand\cotx  {\cot x}
\newcommand\cscx  {\csc x}
\newcommand\sinhx {\sinh x}
\newcommand\coshx {\cosh x}
\newcommand\tanhx {\tanh x}

\newcommand\seq   {\overset{!}{=}}
\newcommand\slh   {\overset{LH}{=}}
\newcommand\sle   {\overset{!}{\le}}
\newcommand\sge   {\overset{!}{\ge}}
\newcommand\sll   {\overset{!}{<}}
\newcommand\sgg   {\overset{!}{>}}

\newcommand\h     {\hat}
\newcommand\ve    {\vec}
\newcommand\lv    {\overrightarrow}
\newcommand\ol    {\overline}

\newcommand\mlcm  {\mathrm{lcm}}

\DeclareMathOperator{\sech}   {sech}
\DeclareMathOperator{\csch}   {csch}
\DeclareMathOperator{\arcsec} {arcsec}
\DeclareMathOperator{\arccot} {arcCot}
\DeclareMathOperator{\arccsc} {arcCsc}
\DeclareMathOperator{\arccosh}{arccosh}
\DeclareMathOperator{\arcsinh}{arcsinh}
\DeclareMathOperator{\arctanh}{arctanh}
\DeclareMathOperator{\arcsech}{arcsech}
\DeclareMathOperator{\arccsch}{arccsch}
\DeclareMathOperator{\arccoth}{arccoth}
\DeclareMathOperator{\atant}  {atan2} 

\newcommand\dx    {\,\mathrm{d}x}
\newcommand\dt    {\,\mathrm{d}t}
\newcommand\dtt   {\,\mathrm{d}\theta}
\newcommand\du    {\,\mathrm{d}u}
\newcommand\dv    {\,\mathrm{d}v}
\newcommand\df    {\mathrm{d}f}
\newcommand\dfdx  {\diff{f}{x}}
\newcommand\dit   {\limhz \frac{f(x + h) - f(x)}{h}}

\newcommand\nt[1] {\frac{#1}{#1}}

\newcommand\limz  {\lim_{x \to 0}}
\newcommand\limxz {\lim_{x \to x_0}}
\newcommand\limi  {\lim_{x \to \infty}}
\newcommand\limh  {\lim_{x \to 0}}
\newcommand\limni {\lim_{x \to - \infty}}
\newcommand\limpmi{\lim_{x \to \pm \infty}}

\newcommand\ta    {\theta}
\newcommand\ap    {\alpha}

\renewcommand\inf {\infty}
\newcommand  \ninf{-\inf}

% Combinatorics shortcuts
\newcommand\sumnk     {\sum_{k = 0}^{n}}
\newcommand\sumni     {\sum_{i = 0}^{n}}
\newcommand\sumnko    {\sum_{k = 1}^{n}}
\newcommand\sumnio    {\sum_{i = 1}^{n}}
\newcommand\sumai     {\sum_{i = 1}^{n} A_i}
\newcommand\nsum[2]   {\reflectbox{\displaystyle\sum_{\reflectbox{\scriptsize$#1$}}^{\reflectbox{\scriptsize$#2$}}}}

\newcommand\bink      {\binom{n}{k}}
\newcommand\setn      {\{a_i\}^{2n}_{i = 1}}
\newcommand\setc[1]   {\{a_i\}^{#1}_{i = 1}}

\newcommand\cupain    {\bigcup_{i = 1}^{n} A_i}
\newcommand\cupai[1]  {\bigcup_{i = 1}^{#1} A_i}
\newcommand\cupiiai   {\bigcup_{i \in I} A_i}
\newcommand\capain    {\bigcap_{i = 1}^{n} A_i}
\newcommand\capai[1]  {\bigcap_{i = 1}^{#1} A_i}
\newcommand\capiiai   {\bigcap_{i \in I} A_i}

\newcommand\xot       {x_{1, 2}}
\newcommand\ano       {a_{n - 1}}
\newcommand\ant       {a_{n - 2}}

% Other shortcuts
\newcommand\tl    {\tilde}
\newcommand\op    {^{-1}}

\newcommand\sof[1]    {\left | #1 \right |}
\newcommand\cl [1]    {\left ( #1 \right )}
\newcommand\csb[1]    {\left [ #1 \right ]}

\newcommand\bs    {\blacksquare}

%! ~~~ Document ~~~

\author{שחר פרץ}
\title{תוכנה 1}
\begin{document}
	\maketitle
	
	\section{\en{Compiling and interpitation}}
	
	בהתינתן שפת ביוטויים שנרצה לחשב. יהיו שתי אפשרויות: 
	לקחת את השפה, לחשב, ולהציג תוצאה. השנייה, לעשות הכנה מראש, חישוב, ותוצאה. 
	
	ההכנה מראש תיקח זמן, אבל תגרום לחישוב להיות יותר מהיר. interpeter לא יעשה הכנה מראש, בעוד compiler הוא השלה של ההכנה מראש. 
	
	המרצה כתב שפה עם קומפיילר, אופטימייזר (משפר את הקוד המקומפל) ואינטפטר לשפה שהוא המציא. השפה היא שפה של ביטויים אלגברים. 
	
	נקרא לשפה ביטויים פשוטים. נאשר פרמטרים (משתנים) כגון x, y, z\_37	 וכו'. נאשר מספרים שלמים, ופעולות חשבון (רק $+, -, \cdot, \op$). נאשר סוגריים, אך פרט לכך אין סדר פעולות חשבון. לדוגמה, $2 + 3 \cdot 4 = 20$. 
	
	כלומר, no operator precedence (כלומר, אין קדימות לאופרטואים כאלו ואחרים). לדוגמה, ב־java: 
	\ttt{if x + 5 < 8 \&\& y + 7  < 3}
	
	השפה היא right accosiative (לא משנה כי אין קדימות), כלומר החישוב מימין לשמאל. רוב השפות הפוכות. 
	
	נשים סוגריים כדי להגדיר קדימות: 
	\ttt{((x + 5) < 8) \&\& ((y * 7) < 2)}
	
	נעזוב את java לבינתיים. 
	
	\section{\en{``Simple Expressions" Compiling}}
	lexical analysis -- ניתוח של השפה. לדוגמה: 
	\begin{enumerate}
		\item רצף ספרות \dotfill ספרות
		\item אות – אחריה ספרות או אותיות \dotfill פרמטר
		\item +, -, *, / \dotfill אופרטורים
	\end{enumerate}
	
	\subsection{Regex}
	regular expressions. 
	דוגמאות:
	
	\slash dt -- מספר בין 0-9
	
	[a - zA - Z] -- רצף תווים
	
	אגב, בג'אווה regex־ים מתקמפלים בנפרד. 
	
	שיטת האינטפרפיטציה שלהן, כדלהלן:
	 \begin{itemize}
	 	\item מספר $\reflectbox{$\mapsto$}$ LV (תשמור בצד ותמשיך). 
	 	\item פרמטר $\reflectbox{$\mapsto$}$ שלוף מה־dict. 
	 	\item אופרטור $\reflectbox{$\mapsto$}$ רוקורסיה על מה שנשאר, על ביטוי אטומי (מספר או פרמטר). 
	 	\item סוגריים $\reflectbox{$\mapsto$}$ רקורסיה על מה שנמצא אחרי הסוגריים, עד שרואים סגור סוגריים. 
	 \end{itemize}
	 
	 ככה נקבל דברים מדהימים כמו \ttt{1 - 4 + 5 = -4}. 
	 
	 \subsection{AST}
	 abstrcut syntax tree, מתייחס להתליך של לקחת את ה־string, לחסוך את תהליך ה‏prasing (לנתח מחרוזת והבנת התחביר בה) בכך שה־output יהפוך לעץ. לא נעשה את זה. 
	 
	 \section{\en{Notes about java}}
	 
	 Map הוא dict ב־java. יש כמה אימפלמנטציות ל־dict, כמו hash map, tree map וכו'. 
	 
	 לליטרלים יש סוג. לדוגמה 5 הוא ליטרל מסוג int, בעוד 5L יהיה long, יתקיים 3.14 ש־double ואחרונה 3.14F יהיה float. 
	 
	 אל תשוו float באמצעות == כי זה לא מדויק מספיק. פר פלטפורמה (אפילו amd vs. mac או gpu vs. cpu) התוצאה יכול ה להשתנות במקצת. תמיד להשוות עד לכדי אפסילון (טולרנס). 
	 
	 סוגים פרימטייבים -- int, float, double, long וכו'. הם סוגים שקיימים ב־JVM ובד"כ גם קיימים בחומרה. לעומתם, יש גם classes כמו Float. לעומת זה, float הוא לא class, ולכן אין לו methods. יש לו static methods   כמו float.parse Float. זה חשוב, כי בכל מקום שבו ג'אווה מחזיק contaniners, ג'אווה יכול להחזיק רק pointers, ולכן צריך להשתמש ב־class wrappers  של הפרימיטיבים. ה־exception היחיד הוא array, שהוא פרימיטי שמנוהל ע"י ה־JVM. 
	 
	 \section{\en{HeniaCoins}}
	 big-endiand/little-endian -- מגדיר את הסדר בו דברים נשלחים ברשת. (כאשר big endiann אומר להתחיל מהחזקה הגדולה). 
	 לשיעור הבא: להרחיב את ה־blockchain מעבר ל־1, ולעשות validation ל־blockchain. כלומר, צריך: 
	 \begin{itemize}
	 	\item לייצר blockchain של 3 מטבעות
	 	\item לעשות validate ל־chain. 
	 \end{itemize}
	 
	 אימייל: 
	 
	 tal.frangi@gmail.com
	 
	 
\end{document}